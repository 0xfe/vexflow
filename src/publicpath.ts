// publicPath is a webpack option that specifies the base path for loading JS chunk files.
// Normally, it is determined automatically, and assumed to be the same path as the main entry point.
//
// From the webpack documentation:
//   When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually
//   or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
//
// Instead of using 'auto', our Gruntfile.js passes in the empty string so we can allow the developer to
// specify the publicPath at runtime via the global `VEX_BASE_PATH` variable.
//
// If `VEX_BASE_PATH` is not specified, we fall back to a method for automatically determining the base path from
// a combination of document.currentScript, script.src, or self.location.
// The method is inspired by code generated by webpack when the publicPath config is set to 'auto'.
// See: https://webpack.js.org/guides/public-path/#automatic-publicpath

/* eslint-disable no-console */

import { globalObject } from './util';

const globalObj = globalObject();

declare global {
  // eslint-disable-next-line
  let __webpack_public_path__: any;
}

let scriptPath: string | undefined;

console.log(`THE __webpack_public_path__ WAS: [${__webpack_public_path__}]`);

if (globalObj.VEX_BASE_PATH) {
  scriptPath = globalObj.VEX_BASE_PATH;
  console.log(`THE script's base path WAS MANUALLY SPECIFIED [${scriptPath}]`);
} else if (__webpack_public_path__ === 'VEX_AUTO') {
  console.log("Let's figure out the base path automatically");

  // WORKER
  if (globalObj.importScripts) {
    scriptPath = globalObj.location.href;
    // scriptPath = self.location + "";

    console.log('I AM A WORKER');
    console.log('scriptPath is', scriptPath);
  }

  // REGULAR JS SCRIPT TAG
  const document = globalObj.document;
  if (!scriptPath && document) {
    console.log("I'M JUST A SCRIPT TAG");
    if (document.currentScript) {
      scriptPath = document.currentScript.src;

      console.log('document.currentScript.src is ' + scriptPath);
    }

    // If that still didn't work, look for the last <script> tag.
    // This can fail in edge cases.
    if (!scriptPath) {
      const scripts = document.getElementsByTagName('script');
      if (scripts.length) scriptPath = scripts[scripts.length - 1].src;
    }
  }

  if (scriptPath) {
    console.log("Fix up the scriptPath. It's currently: ", scriptPath);
    // Determine the current folder or path of the script.
    scriptPath = scriptPath
      .replace(/#.*$/, '') // remove hash
      .replace(/\?.*$/, '') // remove query
      .replace(/\/[^/]+$/, '/'); // remove everything after the last slash
    console.log("It's now: ", scriptPath);
  } else {
    console.log("OK, we give up! Let's make a guess.");
    scriptPath = './';
  }
} else {
  console.log("LET'S JUST USE ./");
  scriptPath = './';
}

__webpack_public_path__ = scriptPath;
console.log('The publicPath is now set to ' + __webpack_public_path__);
