// publicPath is a webpack option that specifies the base path for loading JS chunk files.
// Normally, it is determined automatically, and assumed to be the same path as the main entry point.
//
// From the webpack documentation:
//   When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually
//   or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
//
// Instead of using 'auto', our Gruntfile.js passes in the empty string so we can allow the developer to
// specify the publicPath at runtime via the global `VEX_BASE_PATH` variable.
//
// If `VEX_BASE_PATH` is not specified, we fall back to a method for automatically determining the base path from
// a combination of document.currentScript, script.src, or self.location.
// The method is inspired by code generated by webpack when the publicPath config is set to 'auto'.
// See: https://webpack.js.org/guides/public-path/#automatic-publicpath

/* eslint-disable no-console */

import { globalObject } from './util';

const globalObj = globalObject();

declare global {
  // eslint-disable-next-line
  let __webpack_public_path__: any;
}

let scriptPath: string | undefined;

if (globalObj.VEX_BASE_PATH) {
  scriptPath = globalObj.VEX_BASE_PATH;
  console.log('THE PUBLICPATH WAS MANUALLY SPECIFIED', scriptPath);
} else {
  console.log("Let's figure out the public path automatically");
  // WORKER
  if (globalObj.importScripts) {
    scriptPath = globalObj.location.href;
    // scriptPath = self.location + "";

    console.log('I AM A WORKER');
    console.log('scriptPath is', scriptPath);
  }

  const document = globalObj.document;

  // REGULAR JS SCRIPT TAG
  if (!scriptPath && document) {
    console.log("I'M JUST A SCRIPT TAG");
    if (document.currentScript) {
      scriptPath = document.currentScript.src;

      console.log('document.currentScript.src is ' + scriptPath);
    }

    // If that still didn't work, look for the last <script> tag.
    // This can fail in edge cases.
    if (!scriptPath) {
      const scripts = document.getElementsByTagName('script');
      if (scripts.length) scriptPath = scripts[scripts.length - 1].src;
    }
  }

  if (scriptPath) {
    console.log("Fix up the scriptPath. It's currently: ", scriptPath);
    // Determine the current folder or path of the script.
    scriptPath = scriptPath
      .replace(/#.*$/, '') // remove hash
      .replace(/\?.*$/, '') // remove query
      .replace(/\/[^\/]+$/, '/'); // remove everything after the last slash
    console.log("It's now: ", scriptPath);
  } else {
    console.log("OK, we give up! Let's make a guess.");
    scriptPath = './';
  }
}

console.log('BEFORE THE PUBLIC PATH WAS: ', __webpack_public_path__);
__webpack_public_path__ = scriptPath;
console.log('The publicPath is now set to ' + __webpack_public_path__);

/*
webpack/runtime/publicPath
(() => {
	var scriptUrl;
	if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
	var document = __webpack_require__.g.document;
	if (!scriptUrl && document) {
		if (document.currentScript)
			scriptUrl = document.currentScript.src
		if (!scriptUrl) {
			var scripts = document.getElementsByTagName("script");
			if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
		}
	}
	if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
	scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
	__webpack_require__.p = scriptUrl;
})();
*/
