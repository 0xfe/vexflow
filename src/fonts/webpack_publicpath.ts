/// <reference types="webpack/module" />

import { globalObject } from '../util';

// publicPath is a webpack option that specifies the base path for dynamically loading JS chunk files.
// Normally, it is assumed to be the same path as the main entry point.
// However, webpack cannot automatically determine this path in all cases.
//
// From the webpack documentation:
//   When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually
//   or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
//
// Instead of using 'auto':
// - our Gruntfile.js allows the developer to manually set the publicPath at **compile time** via the `VEX_BASE_PATH` environment variable.
// - of the developer can specify the base path at runtime via a global `VEX_BASE_PATH` variable. For example, window.VEX_BASE_PATH = '/my/path/'.
//
// If `VEX_BASE_PATH` is not specified via either of the above methods, this script will attempt to determine the base path
// automatically from a combination of document.currentScript, script.src, or self.location.
// The method is inspired by code generated by webpack when the publicPath config is set to 'auto'.
// See: https://webpack.js.org/guides/public-path/#automatic-publicpath
// See: https://webpack.js.org/api/module-variables/#__webpack_chunk_load__-webpack-specific
// Determine the current folder or path of the script.

// This module is imported by async.ts for the CJS build.
// This module is NOT NEEDED in the ESM build, so the file is excluded by tsconfig.esm.json.

// globalThis | self | window | global | this
const g = globalObject();

// Only available in web workers.
// eslint-disable-next-line
declare let importScripts: any;

// Replace the webpack chunk loader with one that tests multiple paths.
const originalLoad = __webpack_chunk_load__;
const publicPaths: string[] = [];
__webpack_chunk_load__ = async (chunkId: string | number) => {
  for (const path of publicPaths) {
    // Set this to tell webpack where to find the JS chunk file.
    __webpack_public_path__ = path;
    try {
      // Special case: web workers need to use importScripts.
      if (typeof importScripts === 'function') {
        const scriptURL = path + __webpack_get_script_filename__(chunkId);
        importScripts(scriptURL);
        return;
      } else {
        return await originalLoad(chunkId);
      }
    } catch (e) {
      // DO NOTHING
    }
  }
};

// Helper
function parentFolder(path: string): string {
  return path
    .replace(/#.*$/, '') // remove hash
    .replace(/\?.*$/, '') // remove query
    .replace(/\/[^/]+$/, '/'); // remove everything after the last slash
}

// Helper
function addPublicPath(path: string): void {
  if (!publicPaths.includes(path)) {
    publicPaths.push(path);
  }
}

// The chunk file base path was specified manually, so we should try it first.
if (g.VEX_BASE_PATH) {
  addPublicPath(g.VEX_BASE_PATH);
}

if (typeof __webpack_public_path__ !== 'undefined') {
  addPublicPath(__webpack_public_path__);
}

// WEB WORKER
// See: vexflow/demos/worker/
if (typeof importScripts === 'function') {
  addPublicPath(parentFolder(g.location.href));
}

// SCRIPT TAG
const document = g.document;
if (document?.currentScript) {
  addPublicPath(parentFolder(document.currentScript.src));
}

if (document?.getElementsByTagName) {
  const scripts = document.getElementsByTagName('script');
  if (scripts.length > 0) {
    addPublicPath(parentFolder(scripts[scripts.length - 1].src));
  }
}

addPublicPath('./');
addPublicPath('/');
