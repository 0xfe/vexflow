<!DOCTYPE html>

<html>
<head>
  <title>beam.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="public/stylesheets/normalize.css" />
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div class="container">
    <div class="page">

      <div class="header">
        
          <h1>beam.js</h1>
        

        
          <div class="toc">
            <h3>Table of Contents</h3>
            <ol>
              
                
                <li>
                  <a class="source" href="accidental.html">
                    accidental.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="annotation.html">
                    annotation.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="articulation.html">
                    articulation.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="barnote.html">
                    barnote.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="beam.html">
                    beam.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="bend.html">
                    bend.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="boundingbox.html">
                    boundingbox.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="canvascontext.html">
                    canvascontext.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="clef.html">
                    clef.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="clefnote.html">
                    clefnote.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="crescendo.html">
                    crescendo.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="curve.html">
                    curve.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="dot.html">
                    dot.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="flow.html">
                    flow.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="vexflow_font.html">
                    vexflow_font.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="formatter.html">
                    formatter.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="fraction.html">
                    fraction.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="frethandfinger.html">
                    frethandfinger.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="ghostnote.html">
                    ghostnote.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="glyph.html">
                    glyph.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="gracenote.html">
                    gracenote.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="gracenotegroup.html">
                    gracenotegroup.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="keymanager.html">
                    keymanager.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="keysignature.html">
                    keysignature.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="modifier.html">
                    modifier.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="modifiercontext.html">
                    modifiercontext.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="music.html">
                    music.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="note.html">
                    note.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="notehead.html">
                    notehead.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="ornament.html">
                    ornament.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="pedalmarking.html">
                    pedalmarking.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="raphaelcontext.html">
                    raphaelcontext.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="renderer.html">
                    renderer.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stave.html">
                    stave.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stavebarline.html">
                    stavebarline.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="staveconnector.html">
                    staveconnector.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stavehairpin.html">
                    stavehairpin.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="staveline.html">
                    staveline.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stavemodifier.html">
                    stavemodifier.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stavenote.html">
                    stavenote.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="staverepetition.html">
                    staverepetition.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stavesection.html">
                    stavesection.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stavetempo.html">
                    stavetempo.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stavetext.html">
                    stavetext.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stavetie.html">
                    stavetie.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stavevolta.html">
                    stavevolta.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stem.html">
                    stem.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stemmablenote.html">
                    stemmablenote.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stringnumber.html">
                    stringnumber.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="strokes.html">
                    strokes.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tables.html">
                    tables.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tabnote.html">
                    tabnote.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tabslide.html">
                    tabslide.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tabstave.html">
                    tabstave.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tabtie.html">
                    tabtie.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="textbracket.html">
                    textbracket.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="textdynamics.html">
                    textdynamics.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="textnote.html">
                    textnote.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tickable.html">
                    tickable.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tickcontext.html">
                    tickcontext.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="timesignature.html">
                    timesignature.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="timesignote.html">
                    timesignote.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tremolo.html">
                    tremolo.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tuning.html">
                    tuning.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tuplet.html">
                    tuplet.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="vex.html">
                    vex.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="vibrato.html">
                    vibrato.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="voice.html">
                    voice.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="voicegroup.html">
                    voicegroup.js
                  </a>
                </li>
              
            </ol>
          </div>
        
      </div>

      
        
        <p><a href="http://vexflow.com">VexFlow</a> - Copyright (c) Mohit Muthanna 2010.</p>
<h2 id="description">Description</h2>
<p>This file implements <code>Beams</code> that span over a set of <code>StemmableNotes</code>.</p>
<p>Requires: vex.js, vexmusic.js, note.js</p>

        
          <div class='highlight'><pre>Vex.Flow.Beam = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Beam</span><span class="hljs-params">(notes, auto_stem)</span> </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">this</span>.init(notes, auto_stem);
  }

  <span class="hljs-keyword">var</span> Stem = Vex.Flow.Stem;</pre></div>
        
      
        
        <h2 id="prototype-methods">Prototype Methods</h2>

        
          <div class='highlight'><pre>  Beam.prototype = {
    init: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(notes, auto_stem)</span> </span>{
      <span class="hljs-keyword">if</span> (!notes || notes == []) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RuntimeError(<span class="hljs-string">"BadArguments"</span>, <span class="hljs-string">"No notes provided for beam."</span>);
      }

      <span class="hljs-keyword">if</span> (notes.length == <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RuntimeError(<span class="hljs-string">"BadArguments"</span>, <span class="hljs-string">"Too few notes for beam."</span>);
      }</pre></div>
        
      
        
        <p>Validate beam line, direction and ticks.</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">this</span>.ticks = notes[<span class="hljs-number">0</span>].getIntrinsicTicks();

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.ticks &gt;= Vex.Flow.durationToTicks(<span class="hljs-string">"4"</span>)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RuntimeError(<span class="hljs-string">"BadArguments"</span>,
            <span class="hljs-string">"Beams can only be applied to notes shorter than a quarter note."</span>);
      }

      <span class="hljs-keyword">var</span> i; <span class="hljs-comment">// shared iterator</span>
      <span class="hljs-keyword">var</span> note;

      <span class="hljs-keyword">this</span>.stem_direction = Stem.UP;

      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; notes.length; ++i) {
        note = notes[i];
        <span class="hljs-keyword">if</span> (note.hasStem()) {
          <span class="hljs-keyword">this</span>.stem_direction = note.getStemDirection();
          <span class="hljs-keyword">break</span>;
        }
      }

      <span class="hljs-keyword">var</span> stem_direction = <span class="hljs-keyword">this</span>.stem_direction;</pre></div>
        
      
        
        <p>Figure out optimal stem direction based on given notes</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">if</span> (auto_stem &amp;&amp; notes[<span class="hljs-number">0</span>].getCategory() === <span class="hljs-string">'stavenotes'</span>)  {
        stem_direction = calculateStemDirection(notes);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (auto_stem &amp;&amp; notes[<span class="hljs-number">0</span>].getCategory() === <span class="hljs-string">'tabnotes'</span>) {</pre></div>
        
      
        
        <p>Auto Stem TabNotes</p>

        
          <div class='highlight'><pre>        <span class="hljs-keyword">var</span> stem_weight = notes.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(memo, note)</span> </span>{
          <span class="hljs-keyword">return</span> memo + note.stem_direction;
        }, <span class="hljs-number">0</span>);

        stem_direction = stem_weight &gt; -<span class="hljs-number">1</span> ? Stem.UP : Stem.DOWN;
      }</pre></div>
        
      
        
        <p>Apply stem directions and attach beam to notes</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; notes.length; ++i) {
        note = notes[i];
        <span class="hljs-keyword">if</span> (auto_stem) {
          note.setStemDirection(stem_direction);
          <span class="hljs-keyword">this</span>.stem_direction = stem_direction;
        }
        note.setBeam(<span class="hljs-keyword">this</span>);
      }

      <span class="hljs-keyword">this</span>.postFormatted = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">this</span>.notes = notes;
      <span class="hljs-keyword">this</span>.beam_count = <span class="hljs-keyword">this</span>.getBeamCount();
      <span class="hljs-keyword">this</span>.break_on_indices = [];
      <span class="hljs-keyword">this</span>.render_options = {
        beam_width: <span class="hljs-number">5</span>,
        max_slope: <span class="hljs-number">0.25</span>,
        min_slope: -<span class="hljs-number">0.25</span>,
        slope_iterations: <span class="hljs-number">20</span>,
        slope_cost: <span class="hljs-number">100</span>,
        show_stemlets: <span class="hljs-literal">false</span>,
        stemlet_extension: <span class="hljs-number">7</span>,
        partial_beam_length: <span class="hljs-number">10</span>
      };
    },</pre></div>
        
      
        
        <p>The the rendering <code>context</code></p>

        
          <div class='highlight'><pre>    setContext: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(context)</span> </span>{ <span class="hljs-keyword">this</span>.context = context; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; },</pre></div>
        
      
        
        <p>Get the notes in this beam</p>

        
          <div class='highlight'><pre>    getNotes: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.notes; },</pre></div>
        
      
        
        <p>Get the max number of beams in the set of notes</p>

        
          <div class='highlight'><pre>    getBeamCount: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
      <span class="hljs-keyword">var</span> beamCounts =  <span class="hljs-keyword">this</span>.notes.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(note)</span> </span>{
        <span class="hljs-keyword">return</span> note.getGlyph().beam_count;
      });

      <span class="hljs-keyword">var</span> maxBeamCount =  beamCounts.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(max, beamCount)</span> </span>{
          <span class="hljs-keyword">return</span> beamCount &gt; max ? beamCount : max;
      });

      <span class="hljs-keyword">return</span> maxBeamCount;
    },</pre></div>
        
      
        
        <p>Set which note <code>indices</code> to break the secondary beam at</p>

        
          <div class='highlight'><pre>    breakSecondaryAt: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(indices)</span> </span>{
      <span class="hljs-keyword">this</span>.break_on_indices = indices;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    },</pre></div>
        
      
        
        <p>Return the y coordinate for linear function</p>

        
          <div class='highlight'><pre>    getSlopeY: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x, first_x_px, first_y_px, slope)</span> </span>{
      <span class="hljs-keyword">return</span> first_y_px + ((x - first_x_px) * slope);
    },</pre></div>
        
      
        
        <p>Calculate the best possible slope for the provided notes</p>

        
          <div class='highlight'><pre>    calculateSlope: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> first_note = <span class="hljs-keyword">this</span>.notes[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">var</span> first_y_px = first_note.getStemExtents().topY;
      <span class="hljs-keyword">var</span> first_x_px = first_note.getStemX();

      <span class="hljs-keyword">var</span> inc = (<span class="hljs-keyword">this</span>.render_options.max_slope - <span class="hljs-keyword">this</span>.render_options.min_slope) /
          <span class="hljs-keyword">this</span>.render_options.slope_iterations;
      <span class="hljs-keyword">var</span> min_cost = <span class="hljs-built_in">Number</span>.MAX_VALUE;
      <span class="hljs-keyword">var</span> best_slope = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> y_shift = <span class="hljs-number">0</span>;</pre></div>
        
      
        
        <p>iterate through slope values to find best weighted fit</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> slope = <span class="hljs-keyword">this</span>.render_options.min_slope;
           slope &lt;= <span class="hljs-keyword">this</span>.render_options.max_slope;
           slope += inc) {
        <span class="hljs-keyword">var</span> total_stem_extension = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">var</span> y_shift_tmp = <span class="hljs-number">0</span>;</pre></div>
        
      
        
        <p>iterate through notes, calculating y shift and stem extension</p>

        
          <div class='highlight'><pre>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-keyword">this</span>.notes.length; ++i) {
          <span class="hljs-keyword">var</span> note = <span class="hljs-keyword">this</span>.notes[i];

          <span class="hljs-keyword">var</span> x_px = note.getStemX();
          <span class="hljs-keyword">var</span> y_px = note.getStemExtents().topY;
          <span class="hljs-keyword">var</span> slope_y_px = <span class="hljs-keyword">this</span>.getSlopeY(x_px, first_x_px, first_y_px, slope) + y_shift_tmp;</pre></div>
        
      
        
        <p>beam needs to be shifted up to accommodate note</p>

        
          <div class='highlight'><pre>          <span class="hljs-keyword">if</span> (y_px * <span class="hljs-keyword">this</span>.stem_direction &lt; slope_y_px * <span class="hljs-keyword">this</span>.stem_direction) {
            <span class="hljs-keyword">var</span> diff =  <span class="hljs-built_in">Math</span>.abs(y_px - slope_y_px);
            y_shift_tmp += diff * -<span class="hljs-keyword">this</span>.stem_direction;
            total_stem_extension += (diff * i);
          } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// beam overshoots note, account for the difference</span>
            total_stem_extension += (y_px - slope_y_px) * <span class="hljs-keyword">this</span>.stem_direction;
          }

        }

        <span class="hljs-keyword">var</span> last_note = <span class="hljs-keyword">this</span>.notes[<span class="hljs-keyword">this</span>.notes.length - <span class="hljs-number">1</span>];
        <span class="hljs-keyword">var</span> first_last_slope = ((last_note.getStemExtents().topY - first_y_px) /
                (last_note.getStemX() - first_x_px));</pre></div>
        
      
        
        <p>most engraving books suggest aiming for a slope about half the angle of the
difference between the first and last notes’ stem length;</p>

        
          <div class='highlight'><pre>        <span class="hljs-keyword">var</span> ideal_slope = first_last_slope / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">var</span> distance_from_ideal = <span class="hljs-built_in">Math</span>.abs(ideal_slope - slope);</pre></div>
        
      
        
        <p>This tries to align most beams to something closer to the ideal_slope, but
doesn’t go crazy. To disable, set this.render_options.slope_cost = 0</p>

        
          <div class='highlight'><pre>        <span class="hljs-keyword">var</span> cost = <span class="hljs-keyword">this</span>.render_options.slope_cost * distance_from_ideal +
            <span class="hljs-built_in">Math</span>.abs(total_stem_extension);</pre></div>
        
      
        
        <p>update state when a more ideal slope is found</p>

        
          <div class='highlight'><pre>        <span class="hljs-keyword">if</span> (cost &lt; min_cost) {
          min_cost = cost;
          best_slope = slope;
          y_shift = y_shift_tmp;
        }
      }

      <span class="hljs-keyword">this</span>.slope = best_slope;
      <span class="hljs-keyword">this</span>.y_shift = y_shift;
    },</pre></div>
        
      
        
        <p>Create new stems for the notes in the beam, so that each stem
extends into the beams.</p>

        
          <div class='highlight'><pre>    applyStemExtensions: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
      <span class="hljs-keyword">var</span> first_note = <span class="hljs-keyword">this</span>.notes[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">var</span> first_y_px = first_note.getStemExtents().topY;
      <span class="hljs-keyword">var</span> first_x_px = first_note.getStemX();

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.notes.length; ++i) {
        <span class="hljs-keyword">var</span> note = <span class="hljs-keyword">this</span>.notes[i];

        <span class="hljs-keyword">var</span> x_px = note.getStemX();
        <span class="hljs-keyword">var</span> y_extents = note.getStemExtents();
        <span class="hljs-keyword">var</span> base_y_px = y_extents.baseY;
        <span class="hljs-keyword">var</span> top_y_px = y_extents.topY;</pre></div>
        
      
        
        <p>For harmonic note heads, shorten stem length by 3 pixels</p>

        
          <div class='highlight'><pre>        base_y_px += <span class="hljs-keyword">this</span>.stem_direction * note.glyph.stem_offset;</pre></div>
        
      
        
        <p>Don’t go all the way to the top (for thicker stems)</p>

        
          <div class='highlight'><pre>        <span class="hljs-keyword">var</span> y_displacement = Vex.Flow.STEM_WIDTH;

        <span class="hljs-keyword">if</span> (!note.hasStem()) {
          <span class="hljs-keyword">if</span> (note.isRest() &amp;&amp; <span class="hljs-keyword">this</span>.render_options.show_stemlets) {
            <span class="hljs-keyword">var</span> centerGlyphX = note.getCenterGlyphX();

            <span class="hljs-keyword">var</span> width = <span class="hljs-keyword">this</span>.render_options.beam_width;
            <span class="hljs-keyword">var</span> total_width = ((<span class="hljs-keyword">this</span>.beam_count - <span class="hljs-number">1</span>)* width * <span class="hljs-number">1.5</span>) + width;

            <span class="hljs-keyword">var</span> stemlet_height = (total_width - y_displacement +
              <span class="hljs-keyword">this</span>.render_options.stemlet_extension);

            <span class="hljs-keyword">var</span> beam_y = <span class="hljs-keyword">this</span>.getSlopeY(centerGlyphX, first_x_px,
                            first_y_px, <span class="hljs-keyword">this</span>.slope) + <span class="hljs-keyword">this</span>.y_shift;
            <span class="hljs-keyword">var</span> start_y = beam_y + (Vex.Flow.Stem.HEIGHT * <span class="hljs-keyword">this</span>.stem_direction);
            <span class="hljs-keyword">var</span> end_y = beam_y + (stemlet_height * <span class="hljs-keyword">this</span>.stem_direction);</pre></div>
        
      
        
        <p>Draw Stemlet</p>

        
          <div class='highlight'><pre>            note.setStem(<span class="hljs-keyword">new</span> Vex.Flow.Stem({
              x_begin: centerGlyphX,
              x_end: centerGlyphX,
              y_bottom: <span class="hljs-keyword">this</span>.stem_direction === <span class="hljs-number">1</span> ? end_y : start_y,
              y_top: <span class="hljs-keyword">this</span>.stem_direction === <span class="hljs-number">1</span> ? start_y : end_y,
              y_extend: y_displacement,
              stem_extension: -<span class="hljs-number">1</span>, <span class="hljs-comment">// To avoid protruding through the beam</span>
              stem_direction: <span class="hljs-keyword">this</span>.stem_direction
            }));
          }

          <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">var</span> slope_y = <span class="hljs-keyword">this</span>.getSlopeY(x_px, first_x_px, first_y_px,
                        <span class="hljs-keyword">this</span>.slope) + <span class="hljs-keyword">this</span>.y_shift;

        note.setStem(<span class="hljs-keyword">new</span> Vex.Flow.Stem({
          x_begin: x_px - (Vex.Flow.STEM_WIDTH/<span class="hljs-number">2</span>),
          x_end: x_px,
          y_top: <span class="hljs-keyword">this</span>.stem_direction === <span class="hljs-number">1</span> ? top_y_px : base_y_px,
          y_bottom: <span class="hljs-keyword">this</span>.stem_direction === <span class="hljs-number">1</span> ? base_y_px :  top_y_px ,
          y_extend: y_displacement,
          stem_extension: <span class="hljs-built_in">Math</span>.abs(top_y_px - slope_y) - Stem.HEIGHT - <span class="hljs-number">1</span>,
          stem_direction: <span class="hljs-keyword">this</span>.stem_direction
        }));
      }
    },</pre></div>
        
      
        
        <p>Get the x coordinates for the beam lines of specific <code>duration</code></p>

        
          <div class='highlight'><pre>    getBeamLines: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(duration)</span> </span>{
      <span class="hljs-keyword">var</span> beam_lines = [];
      <span class="hljs-keyword">var</span> beam_started = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">var</span> current_beam;
      <span class="hljs-keyword">var</span> partial_beam_length = <span class="hljs-keyword">this</span>.render_options.partial_beam_length;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">determinePartialSide</span> <span class="hljs-params">(prev_note, next_note)</span></span>{</pre></div>
        
      
        
        <p>Compare beam counts and store differences</p>

        
          <div class='highlight'><pre>          <span class="hljs-keyword">var</span> unshared_beams = <span class="hljs-number">0</span>;
          <span class="hljs-keyword">if</span> (next_note &amp;&amp; prev_note) {
            unshared_beams = prev_note.getBeamCount() - next_note.getBeamCount();
          }

          <span class="hljs-keyword">var</span> left_partial = duration !== <span class="hljs-string">"8"</span> &amp;&amp; unshared_beams &gt; <span class="hljs-number">0</span>;
          <span class="hljs-keyword">var</span> right_partial = duration !== <span class="hljs-string">"8"</span> &amp;&amp; unshared_beams &lt; <span class="hljs-number">0</span>;

          <span class="hljs-keyword">return</span> {
            left: left_partial,
            right: right_partial
          };
        }

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.notes.length; ++i) {
        <span class="hljs-keyword">var</span> note = <span class="hljs-keyword">this</span>.notes[i];
        <span class="hljs-keyword">var</span> prev_note = <span class="hljs-keyword">this</span>.notes[i-<span class="hljs-number">1</span>];
        <span class="hljs-keyword">var</span> next_note = <span class="hljs-keyword">this</span>.notes[i+<span class="hljs-number">1</span>];
        <span class="hljs-keyword">var</span> ticks = note.getIntrinsicTicks();
        <span class="hljs-keyword">var</span> partial = determinePartialSide(prev_note, next_note);
        <span class="hljs-keyword">var</span> stem_x = note.isRest() ? note.getCenterGlyphX() : note.getStemX();</pre></div>
        
      
        
        <p>Check whether to apply beam(s)</p>

        
          <div class='highlight'><pre>        <span class="hljs-keyword">if</span> (ticks &lt; Vex.Flow.durationToTicks(duration)) {
          <span class="hljs-keyword">if</span> (!beam_started) {
            <span class="hljs-keyword">var</span> new_line = {start: stem_x, end: <span class="hljs-literal">null</span>};

            <span class="hljs-keyword">if</span> (partial.left) {
              new_line.end = stem_x - partial_beam_length;
            }

            beam_lines.push(new_line);
            beam_started = <span class="hljs-literal">true</span>;
          } <span class="hljs-keyword">else</span> {
            current_beam = beam_lines[beam_lines.length - <span class="hljs-number">1</span>];
            current_beam.end = stem_x;</pre></div>
        
      
        
        <p>Should break secondary beams on note</p>

        
          <div class='highlight'><pre>            <span class="hljs-keyword">var</span> should_break = <span class="hljs-keyword">this</span>.break_on_indices.indexOf(i) !== -<span class="hljs-number">1</span>;</pre></div>
        
      
        
        <p>Shorter than or eq an 8th note duration</p>

        
          <div class='highlight'><pre>            <span class="hljs-keyword">var</span> can_break = <span class="hljs-built_in">parseInt</span>(duration, <span class="hljs-number">10</span>) &gt;= <span class="hljs-number">8</span>;
            <span class="hljs-keyword">if</span> (should_break  &amp;&amp; can_break) {
              beam_started = <span class="hljs-literal">false</span>;
            }
          }
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> (!beam_started) {</pre></div>
        
      
        
        <p>we don’t care</p>

        
          <div class='highlight'><pre>          } <span class="hljs-keyword">else</span> {
            current_beam = beam_lines[beam_lines.length - <span class="hljs-number">1</span>];
            <span class="hljs-keyword">if</span> (current_beam.end == <span class="hljs-literal">null</span>) {</pre></div>
        
      
        
        <p>single note</p>

        
          <div class='highlight'><pre>              current_beam.end = current_beam.start +
                                 partial_beam_length;
            } <span class="hljs-keyword">else</span> {</pre></div>
        
      
        
        <p>we don’t care</p>

        
          <div class='highlight'><pre>            }
          }

          beam_started = <span class="hljs-literal">false</span>;
        }
      }

      <span class="hljs-keyword">if</span> (beam_started === <span class="hljs-literal">true</span>) {
        current_beam = beam_lines[beam_lines.length - <span class="hljs-number">1</span>];
        <span class="hljs-keyword">if</span> (current_beam.end == <span class="hljs-literal">null</span>) {</pre></div>
        
      
        
        <p>single note</p>

        
          <div class='highlight'><pre>          current_beam.end = current_beam.start -
              partial_beam_length;
        }
      }

      <span class="hljs-keyword">return</span> beam_lines;
    },</pre></div>
        
      
        
        <p>Render the stems for each notes</p>

        
          <div class='highlight'><pre>    drawStems: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">this</span>.notes.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(note)</span> </span>{
        <span class="hljs-keyword">if</span> (note.getStem()) {
          note.getStem().setContext(<span class="hljs-keyword">this</span>.context).draw();
        }
      }, <span class="hljs-keyword">this</span>);
    },</pre></div>
        
      
        
        <p>Render the beam lines</p>

        
          <div class='highlight'><pre>    drawBeamLines: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.context) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RERR(<span class="hljs-string">"NoCanvasContext"</span>,
          <span class="hljs-string">"Can't draw without a canvas context."</span>);

      <span class="hljs-keyword">var</span> valid_beam_durations = [<span class="hljs-string">"4"</span>, <span class="hljs-string">"8"</span>, <span class="hljs-string">"16"</span>, <span class="hljs-string">"32"</span>, <span class="hljs-string">"64"</span>];

      <span class="hljs-keyword">var</span> first_note = <span class="hljs-keyword">this</span>.notes[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">var</span> last_note = <span class="hljs-keyword">this</span>.notes[<span class="hljs-keyword">this</span>.notes.length - <span class="hljs-number">1</span>];

      <span class="hljs-keyword">var</span> first_y_px = first_note.getStemExtents().topY;
      <span class="hljs-keyword">var</span> last_y_px = last_note.getStemExtents().topY;

      <span class="hljs-keyword">var</span> first_x_px = first_note.getStemX();

      <span class="hljs-keyword">var</span> beam_width = <span class="hljs-keyword">this</span>.render_options.beam_width * <span class="hljs-keyword">this</span>.stem_direction;</pre></div>
        
      
        
        <p>Draw the beams.</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; valid_beam_durations.length; ++i) {
        <span class="hljs-keyword">var</span> duration = valid_beam_durations[i];
        <span class="hljs-keyword">var</span> beam_lines = <span class="hljs-keyword">this</span>.getBeamLines(duration);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; beam_lines.length; ++j) {
          <span class="hljs-keyword">var</span> beam_line = beam_lines[j];
          <span class="hljs-keyword">var</span> first_x = beam_line.start - (<span class="hljs-keyword">this</span>.stem_direction == Stem.DOWN ? Vex.Flow.STEM_WIDTH/<span class="hljs-number">2</span>:<span class="hljs-number">0</span>);
          <span class="hljs-keyword">var</span> first_y = <span class="hljs-keyword">this</span>.getSlopeY(first_x, first_x_px, first_y_px, <span class="hljs-keyword">this</span>.slope);

          <span class="hljs-keyword">var</span> last_x = beam_line.end +
            (<span class="hljs-keyword">this</span>.stem_direction == <span class="hljs-number">1</span> ? (Vex.Flow.STEM_WIDTH/<span class="hljs-number">3</span>):(-Vex.Flow.STEM_WIDTH/<span class="hljs-number">3</span>));
          <span class="hljs-keyword">var</span> last_y = <span class="hljs-keyword">this</span>.getSlopeY(last_x, first_x_px, first_y_px, <span class="hljs-keyword">this</span>.slope);

          <span class="hljs-keyword">this</span>.context.beginPath();
          <span class="hljs-keyword">this</span>.context.moveTo(first_x, first_y + <span class="hljs-keyword">this</span>.y_shift);
          <span class="hljs-keyword">this</span>.context.lineTo(first_x, first_y + beam_width + <span class="hljs-keyword">this</span>.y_shift);
          <span class="hljs-keyword">this</span>.context.lineTo(last_x + <span class="hljs-number">1</span>, last_y + beam_width + <span class="hljs-keyword">this</span>.y_shift);
          <span class="hljs-keyword">this</span>.context.lineTo(last_x + <span class="hljs-number">1</span>, last_y + <span class="hljs-keyword">this</span>.y_shift);
          <span class="hljs-keyword">this</span>.context.closePath();
          <span class="hljs-keyword">this</span>.context.fill();
        }

        first_y_px += beam_width * <span class="hljs-number">1.5</span>;
        last_y_px += beam_width * <span class="hljs-number">1.5</span>;
      }
    },</pre></div>
        
      
        
        <p>Pre-format the beam</p>

        
          <div class='highlight'><pre>    preFormat: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; },</pre></div>
        
      
        
        <p>Post-format the beam. This can only be called after
the notes in the beam have both <code>x</code> and <code>y</code> values. ie: they’ve 
been formatted and have staves</p>

        
          <div class='highlight'><pre>    postFormat: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.postFormatted) <span class="hljs-keyword">return</span>;

      <span class="hljs-keyword">this</span>.calculateSlope();
      <span class="hljs-keyword">this</span>.applyStemExtensions();

      <span class="hljs-keyword">this</span>.postFormatted = <span class="hljs-literal">true</span>;
    },</pre></div>
        
      
        
        <p>Render the beam to the canvas context</p>

        
          <div class='highlight'><pre>    draw: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.context) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RERR(<span class="hljs-string">"NoCanvasContext"</span>,
          <span class="hljs-string">"Can't draw without a canvas context."</span>);

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.unbeamable) <span class="hljs-keyword">return</span>;

      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.postFormatted) {
        <span class="hljs-keyword">this</span>.postFormat();
      }

      <span class="hljs-keyword">this</span>.drawStems();
      <span class="hljs-keyword">this</span>.drawBeamLines();

      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
  };

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calculateStemDirection</span><span class="hljs-params">(notes)</span> </span>{
    <span class="hljs-keyword">var</span> lineSum = <span class="hljs-number">0</span>;
    notes.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(note)</span> </span>{
      <span class="hljs-keyword">if</span> (note.keyProps) {
        note.keyProps.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(keyProp)</span></span>{
          lineSum += (keyProp.line - <span class="hljs-number">3</span>);
        });
      }
    });

    <span class="hljs-keyword">if</span> (lineSum &gt;= <span class="hljs-number">0</span>)
      <span class="hljs-keyword">return</span> Stem.DOWN;
    <span class="hljs-keyword">return</span> Stem.UP;
  }</pre></div>
        
      
        
        <h2 id="static-methods">Static Methods</h2>
<p>Gets the default beam groups for a provided time signature.
Attempts to guess if the time signature is not found in table.
Currently this is fairly naive.</p>

        
          <div class='highlight'><pre>  Beam.getDefaultBeamGroups = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(time_sig)</span></span>{
    <span class="hljs-keyword">if</span> (!time_sig || time_sig == <span class="hljs-string">"c"</span>) time_sig = <span class="hljs-string">"4/4"</span>;

    <span class="hljs-keyword">var</span> defaults = {
      <span class="hljs-string">'1/2'</span> :  [<span class="hljs-string">'1/2'</span>],
      <span class="hljs-string">'2/2'</span> :  [<span class="hljs-string">'1/2'</span>],
      <span class="hljs-string">'3/2'</span> :  [<span class="hljs-string">'1/2'</span>],
      <span class="hljs-string">'4/2'</span> :  [<span class="hljs-string">'1/2'</span>],

      <span class="hljs-string">'1/4'</span> :  [<span class="hljs-string">'1/4'</span>],
      <span class="hljs-string">'2/4'</span> :  [<span class="hljs-string">'1/4'</span>],
      <span class="hljs-string">'3/4'</span> :  [<span class="hljs-string">'1/4'</span>],
      <span class="hljs-string">'4/4'</span> :  [<span class="hljs-string">'1/4'</span>],

      <span class="hljs-string">'1/8'</span> :  [<span class="hljs-string">'1/8'</span>],
      <span class="hljs-string">'2/8'</span> :  [<span class="hljs-string">'2/8'</span>],
      <span class="hljs-string">'3/8'</span> :  [<span class="hljs-string">'3/8'</span>],
      <span class="hljs-string">'4/8'</span> :  [<span class="hljs-string">'2/8'</span>],

      <span class="hljs-string">'1/16'</span> : [<span class="hljs-string">'1/16'</span>],
      <span class="hljs-string">'2/16'</span> : [<span class="hljs-string">'2/16'</span>],
      <span class="hljs-string">'3/16'</span> : [<span class="hljs-string">'3/16'</span>],
      <span class="hljs-string">'4/16'</span> : [<span class="hljs-string">'2/16'</span>]
    };

    <span class="hljs-keyword">var</span> Fraction = Vex.Flow.Fraction;
    <span class="hljs-keyword">var</span> groups = defaults[time_sig];

    <span class="hljs-keyword">if</span> (!groups) {</pre></div>
        
      
        
        <p>If no beam groups found, naively determine
the beam groupings from the time signature</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">var</span> beatTotal = <span class="hljs-built_in">parseInt</span>(time_sig.split(<span class="hljs-string">'/'</span>)[<span class="hljs-number">0</span>], <span class="hljs-number">10</span>);
      <span class="hljs-keyword">var</span> beatValue = <span class="hljs-built_in">parseInt</span>(time_sig.split(<span class="hljs-string">'/'</span>)[<span class="hljs-number">1</span>], <span class="hljs-number">10</span>);

      <span class="hljs-keyword">var</span> tripleMeter = beatTotal % <span class="hljs-number">3</span> === <span class="hljs-number">0</span>;

      <span class="hljs-keyword">if</span> (tripleMeter) {
        <span class="hljs-keyword">return</span> [<span class="hljs-keyword">new</span> Fraction(<span class="hljs-number">3</span>, beatValue)];
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beatValue &gt; <span class="hljs-number">4</span>) {
        <span class="hljs-keyword">return</span> [<span class="hljs-keyword">new</span> Fraction(<span class="hljs-number">2</span>, beatValue)];
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beatValue &lt;= <span class="hljs-number">4</span>) {
        <span class="hljs-keyword">return</span> [<span class="hljs-keyword">new</span> Fraction(<span class="hljs-number">1</span>, beatValue)];
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> groups.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(group)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Fraction().parse(group);
      });
    }
  };</pre></div>
        
      
        
        <p>A helper function to automatically build basic beams for a voice. For more
complex auto-beaming use <code>Beam.generateBeams()</code>.</p>
<p>Parameters:</p>
<ul>
<li><code>voice</code> - The voice to generate the beams for</li>
<li><code>stem_direction</code> - A stem direction to apply to the entire voice</li>
<li><code>groups</code> - An array of <code>Fraction</code> representing beat groupings for the beam</li>
</ul>

        
          <div class='highlight'><pre>  Beam.applyAndGetBeams = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(voice, stem_direction, groups)</span> </span>{
    <span class="hljs-keyword">return</span> Beam.generateBeams(voice.getTickables(), {
      groups: groups,
      stem_direction: stem_direction
    });
  };</pre></div>
        
      
        
        <p>A helper function to autimatically build beams for a voice with
configuration options.</p>
<p>Example configuration object:</p>
<pre><code>config = {
  groups: [<span class="hljs-keyword">new</span> Vex.Flow.Fraction(<span class="hljs-number">2</span>, <span class="hljs-number">8</span>)],
  stem_direction: -<span class="hljs-number">1</span>,
  beam_rests: <span class="hljs-literal">true</span>,
  beam_middle_only: <span class="hljs-literal">true</span>,
  show_stemlets: <span class="hljs-literal">false</span>
};
</code></pre><p>Parameters:</p>
<ul>
<li><code>notes</code> - An array of notes to create the beams for</li>
<li><code>config</code> - The configuration object<ul>
<li><code>groups</code> - Array of <code>Fractions</code> that represent the beat structure to beam the notes</li>
<li><code>stem_direction</code> - Set to apply the same direction to all notes</li>
<li><code>beam_rests</code> - Set to <code>true</code> to include rests in the beams</li>
<li><code>beam_middle_only</code> - Set to <code>true</code> to only beam rests in the middle of the beat</li>
<li><code>show_stemlets</code> - Set to <code>true</code> to draw stemlets for rests</li>
<li><code>maintain_stem_directions</code> - Set to <code>true</code> to not apply new stem directions</li>
</ul>
</li>
</ul>

        
          <div class='highlight'><pre>  Beam.generateBeams = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(notes, config)</span> </span>{

    <span class="hljs-keyword">if</span> (!config) config = {};

    <span class="hljs-keyword">if</span> (!config.groups || !config.groups.length) {
      config.groups = [<span class="hljs-keyword">new</span> Vex.Flow.Fraction(<span class="hljs-number">2</span>, <span class="hljs-number">8</span>)];
    }</pre></div>
        
      
        
        <p>Convert beam groups to tick amounts</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">var</span> tickGroups = config.groups.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(group)</span> </span>{
      <span class="hljs-keyword">if</span> (!group.multiply) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RuntimeError(<span class="hljs-string">"InvalidBeamGroups"</span>,
          <span class="hljs-string">"The beam groups must be an array of Vex.Flow.Fractions"</span>);
      }
      <span class="hljs-keyword">return</span> group.clone().multiply(Vex.Flow.RESOLUTION, <span class="hljs-number">1</span>);
    });

    <span class="hljs-keyword">var</span> unprocessedNotes = notes;
    <span class="hljs-keyword">var</span> currentTickGroup = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> noteGroups       = [];
    <span class="hljs-keyword">var</span> currentGroup     = [];

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTotalTicks</span><span class="hljs-params">(vf_notes)</span></span>{
      <span class="hljs-keyword">return</span> vf_notes.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(memo,note)</span></span>{
        <span class="hljs-keyword">return</span> note.getTicks().clone().add(memo);
      }, <span class="hljs-keyword">new</span> Vex.Flow.Fraction(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>));
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nextTickGroup</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">if</span> (tickGroups.length - <span class="hljs-number">1</span> &gt; currentTickGroup) {
        currentTickGroup += <span class="hljs-number">1</span>;
      } <span class="hljs-keyword">else</span> {
        currentTickGroup = <span class="hljs-number">0</span>;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createGroups</span><span class="hljs-params">()</span></span>{
      <span class="hljs-keyword">var</span> nextGroup = [];

      unprocessedNotes.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(unprocessedNote)</span></span>{
        nextGroup    = [];
        <span class="hljs-keyword">if</span> (unprocessedNote.shouldIgnoreTicks()) {
          noteGroups.push(currentGroup);
          currentGroup = nextGroup;
          <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Ignore untickables (like bar notes)</span>
        }

        currentGroup.push(unprocessedNote);
        <span class="hljs-keyword">var</span> ticksPerGroup = tickGroups[currentTickGroup].clone();
        <span class="hljs-keyword">var</span> totalTicks = getTotalTicks(currentGroup);</pre></div>
        
      
        
        <p>Double the amount of ticks in a group, if it’s an unbeamable tuplet</p>

        
          <div class='highlight'><pre>        <span class="hljs-keyword">var</span> unbeamable = Vex.Flow.durationToNumber(unprocessedNote.duration) &lt; <span class="hljs-number">8</span>;
        <span class="hljs-keyword">if</span> (unbeamable &amp;&amp; unprocessedNote.tuplet) {
          ticksPerGroup.numerator *= <span class="hljs-number">2</span>;
        }</pre></div>
        
      
        
        <p>If the note that was just added overflows the group tick total</p>

        
          <div class='highlight'><pre>        <span class="hljs-keyword">if</span> (totalTicks.greaterThan(ticksPerGroup)) {</pre></div>
        
      
        
        <p>If the overflow note can be beamed, start the next group
with it. Unbeamable notes leave the group overflowed.</p>

        
          <div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!unbeamable) {
            nextGroup.push(currentGroup.pop());
          }
          noteGroups.push(currentGroup);
          currentGroup = nextGroup;
          nextTickGroup();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (totalTicks.equals(ticksPerGroup)) {
          noteGroups.push(currentGroup);
          currentGroup = nextGroup;
          nextTickGroup();
        }
      });</pre></div>
        
      
        
        <p>Adds any remainder notes</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">if</span> (currentGroup.length &gt; <span class="hljs-number">0</span>)
        noteGroups.push(currentGroup);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBeamGroups</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> noteGroups.filter(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(group)</span></span>{
          <span class="hljs-keyword">if</span> (group.length &gt; <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">var</span> beamable = <span class="hljs-literal">true</span>;
            group.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(note)</span> </span>{
              <span class="hljs-keyword">if</span> (note.getIntrinsicTicks() &gt;= Vex.Flow.durationToTicks(<span class="hljs-string">"4"</span>)) {
                beamable = <span class="hljs-literal">false</span>;
              }
            });
            <span class="hljs-keyword">return</span> beamable;
          }
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      });
    }</pre></div>
        
      
        
        <p>Splits up groups by Rest</p>

        
          <div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sanitizeGroups</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> sanitizedGroups = [];
      noteGroups.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(group)</span> </span>{
        <span class="hljs-keyword">var</span> tempGroup = [];
        group.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(note, index, group)</span> </span>{
          <span class="hljs-keyword">var</span> isFirstOrLast = index === <span class="hljs-number">0</span> || index === group.length - <span class="hljs-number">1</span>;
          <span class="hljs-keyword">var</span> prevNote = group[index-<span class="hljs-number">1</span>];

          <span class="hljs-keyword">var</span> breaksOnEachRest = !config.beam_rests &amp;&amp; note.isRest();
          <span class="hljs-keyword">var</span> breaksOnFirstOrLastRest = (config.beam_rests &amp;&amp;
            config.beam_middle_only &amp;&amp; note.isRest() &amp;&amp; isFirstOrLast);

          <span class="hljs-keyword">var</span> breakOnStemChange = <span class="hljs-literal">false</span>;
          <span class="hljs-keyword">if</span> (config.maintain_stem_directions &amp;&amp; prevNote &amp;&amp;
              !note.isRest() &amp;&amp; !prevNote.isRest()) {
            <span class="hljs-keyword">var</span> prevDirection = prevNote.getStemDirection();
            <span class="hljs-keyword">var</span> currentDirection = note.getStemDirection();
            breakOnStemChange = currentDirection !== prevDirection;
          }

          <span class="hljs-keyword">var</span> isUnbeamableDuration = <span class="hljs-built_in">parseInt</span>(note.duration, <span class="hljs-number">10</span>) &lt; <span class="hljs-number">8</span>;</pre></div>
        
      
        
        <p>Determine if the group should be broken at this note</p>

        
          <div class='highlight'><pre>          <span class="hljs-keyword">var</span> shouldBreak = breaksOnEachRest || breaksOnFirstOrLastRest ||
                            breakOnStemChange || isUnbeamableDuration;

          <span class="hljs-keyword">if</span> (shouldBreak) {</pre></div>
        
      
        
        <p>Add current group</p>

        
          <div class='highlight'><pre>            <span class="hljs-keyword">if</span> (tempGroup.length &gt; <span class="hljs-number">0</span>) {
              sanitizedGroups.push(tempGroup);
            }</pre></div>
        
      
        
        <p>Start a new group. Include the current note if the group
was broken up by stem direction, as that note needs to start
the next group of notes</p>

        
          <div class='highlight'><pre>            tempGroup = breakOnStemChange ? [note] : [];
          } <span class="hljs-keyword">else</span> {</pre></div>
        
      
        
        <p>Add note to group</p>

        
          <div class='highlight'><pre>            tempGroup.push(note);
          }
        });</pre></div>
        
      
        
        <p>If there is a remaining group, add it as well</p>

        
          <div class='highlight'><pre>        <span class="hljs-keyword">if</span> (tempGroup.length &gt; <span class="hljs-number">0</span>) {
          sanitizedGroups.push(tempGroup);
        }
      });

      noteGroups = sanitizedGroups;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatStems</span><span class="hljs-params">()</span> </span>{
      noteGroups.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(group)</span></span>{
        <span class="hljs-keyword">var</span> stemDirection;
        <span class="hljs-keyword">if</span> (config.maintain_stem_directions) {
          <span class="hljs-keyword">var</span> note = findFirstNote(group);
          stemDirection = note ? note.getStemDirection() : Stem.UP;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> (config.stem_direction){
            stemDirection = config.stem_direction;
          } <span class="hljs-keyword">else</span> {
            stemDirection = calculateStemDirection(group);
          }
        }
        applyStemDirection(group, stemDirection);
      });
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findFirstNote</span><span class="hljs-params">(group)</span> </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; group.length; i++) {
        <span class="hljs-keyword">var</span> note = group[i];
        <span class="hljs-keyword">if</span> (!note.isRest()) {
          <span class="hljs-keyword">return</span> note;
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">applyStemDirection</span><span class="hljs-params">(group, direction)</span> </span>{
      group.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(note)</span></span>{
        note.setStemDirection(direction);
      });
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTupletGroups</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> noteGroups.filter(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(group)</span></span>{
        <span class="hljs-keyword">if</span> (group[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> group[<span class="hljs-number">0</span>].tuplet;
      });
    }</pre></div>
        
      
        
        <p>Using closures to store the variables throughout the various functions
IMO Keeps it this process lot cleaner - but not super consistent with
the rest of the API’s style - Silverwolf90 (Cyril)</p>

        
          <div class='highlight'><pre>    createGroups();
    sanitizeGroups();
    formatStems();</pre></div>
        
      
        
        <p>Get the notes to be beamed</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">var</span> beamedNoteGroups = getBeamGroups();</pre></div>
        
      
        
        <p>Get the tuplets in order to format them accurately</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">var</span> tupletGroups = getTupletGroups();</pre></div>
        
      
        
        <p>Create a Vex.Flow.Beam from each group of notes to be beamed</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">var</span> beams = [];
    beamedNoteGroups.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(group)</span></span>{
      <span class="hljs-keyword">var</span> beam = <span class="hljs-keyword">new</span> Vex.Flow.Beam(group);

      <span class="hljs-keyword">if</span> (config.show_stemlets) {
        beam.render_options.show_stemlets = <span class="hljs-literal">true</span>;
      }

      beams.push(beam);
    });</pre></div>
        
      
        
        <p>Reformat tuplets</p>

        
          <div class='highlight'><pre>    tupletGroups.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(group)</span></span>{
      <span class="hljs-keyword">var</span> firstNote = group[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;group.length; ++i) {
        <span class="hljs-keyword">if</span> (group[i].hasStem()) {
          firstNote = group[i];
          <span class="hljs-keyword">break</span>;
        }
      }

      <span class="hljs-keyword">var</span> tuplet = firstNote.tuplet;

      <span class="hljs-keyword">if</span> (firstNote.beam) tuplet.setBracketed(<span class="hljs-literal">false</span>);
      <span class="hljs-keyword">if</span> (firstNote.stem_direction == Stem.DOWN) {
        tuplet.setTupletLocation(Vex.Flow.Tuplet.LOCATION_BOTTOM);
      }
    });

    <span class="hljs-keyword">return</span> beams;
  };

  <span class="hljs-keyword">return</span> Beam;
}());</pre></div>
        
      
      <div class="fleur">h</div>
    </div>
  </div>
</body>
</html>
