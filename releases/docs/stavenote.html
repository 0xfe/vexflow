<!DOCTYPE html>

<html>
<head>
  <title>stavenote.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="public/stylesheets/normalize.css" />
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div class="container">
    <div class="page">

      <div class="header">
        
          <h1>stavenote.js</h1>
        

        
          <div class="toc">
            <h3>Table of Contents</h3>
            <ol>
              
                
                <li>
                  <a class="source" href="accidental.html">
                    accidental.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="annotation.html">
                    annotation.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="articulation.html">
                    articulation.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="barnote.html">
                    barnote.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="beam.html">
                    beam.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="bend.html">
                    bend.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="boundingbox.html">
                    boundingbox.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="canvascontext.html">
                    canvascontext.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="clef.html">
                    clef.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="clefnote.html">
                    clefnote.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="crescendo.html">
                    crescendo.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="curve.html">
                    curve.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="dot.html">
                    dot.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="flow.html">
                    flow.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="vexflow_font.html">
                    vexflow_font.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="formatter.html">
                    formatter.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="fraction.html">
                    fraction.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="frethandfinger.html">
                    frethandfinger.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="ghostnote.html">
                    ghostnote.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="glyph.html">
                    glyph.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="gracenote.html">
                    gracenote.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="gracenotegroup.html">
                    gracenotegroup.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="keymanager.html">
                    keymanager.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="keysignature.html">
                    keysignature.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="modifier.html">
                    modifier.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="modifiercontext.html">
                    modifiercontext.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="music.html">
                    music.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="note.html">
                    note.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="notehead.html">
                    notehead.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="ornament.html">
                    ornament.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="pedalmarking.html">
                    pedalmarking.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="raphaelcontext.html">
                    raphaelcontext.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="renderer.html">
                    renderer.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stave.html">
                    stave.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stavebarline.html">
                    stavebarline.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="staveconnector.html">
                    staveconnector.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stavehairpin.html">
                    stavehairpin.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="staveline.html">
                    staveline.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stavemodifier.html">
                    stavemodifier.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stavenote.html">
                    stavenote.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="staverepetition.html">
                    staverepetition.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stavesection.html">
                    stavesection.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stavetempo.html">
                    stavetempo.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stavetext.html">
                    stavetext.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stavetie.html">
                    stavetie.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stavevolta.html">
                    stavevolta.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stem.html">
                    stem.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stemmablenote.html">
                    stemmablenote.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stringnumber.html">
                    stringnumber.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="strokes.html">
                    strokes.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tables.html">
                    tables.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tabnote.html">
                    tabnote.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tabslide.html">
                    tabslide.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tabstave.html">
                    tabstave.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tabtie.html">
                    tabtie.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="textbracket.html">
                    textbracket.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="textdynamics.html">
                    textdynamics.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="textnote.html">
                    textnote.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tickable.html">
                    tickable.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tickcontext.html">
                    tickcontext.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="timesignature.html">
                    timesignature.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="timesignote.html">
                    timesignote.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tremolo.html">
                    tremolo.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tuning.html">
                    tuning.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tuplet.html">
                    tuplet.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="vex.html">
                    vex.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="vibrato.html">
                    vibrato.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="voice.html">
                    voice.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="voicegroup.html">
                    voicegroup.js
                  </a>
                </li>
              
            </ol>
          </div>
        
      </div>

      
        
        <p><a href="http://vexflow.com">VexFlow</a> - Copyright (c) Mohit Muthanna 2010.</p>
<h2 id="description">Description</h2>
<p>This file implements notes for standard notation. This consists of one or
more <code>NoteHeads</code>, an optional stem, and an optional flag.</p>
<p><em>Throughout these comments, a “note” refers to the entire <code>StaveNote</code>,
and a “key” refers to a specific pitch/notehead within a note.</em></p>
<p>See <code>tests/stavenote_tests.js</code> for usage examples.</p>

        
          <div class='highlight'><pre>Vex.Flow.StaveNote = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">var</span> StaveNote = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(note_struct)</span> </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">this</span>.init(note_struct);
  };
  StaveNote.CATEGORY = <span class="hljs-string">"stavenotes"</span>;</pre></div>
        
      
        
        <p>To enable logging for this class. Set <code>Vex.Flow.StaveNote.DEBUG</code> to <code>true</code>.</p>

        
          <div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">L</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">if</span> (StaveNote.DEBUG) Vex.L(<span class="hljs-string">"Vex.Flow.StaveNote"</span>, <span class="hljs-built_in">arguments</span>); }

  <span class="hljs-keyword">var</span> Stem = Vex.Flow.Stem;
  <span class="hljs-keyword">var</span> NoteHead = Vex.Flow.NoteHead;</pre></div>
        
      
        
        <p>Stem directions</p>

        
          <div class='highlight'><pre>  StaveNote.STEM_UP = Stem.UP;
  StaveNote.STEM_DOWN = Stem.DOWN;</pre></div>
        
      
        
        <p>Helper methods for rest positioning in ModifierContext.</p>

        
          <div class='highlight'><pre>  <span class="hljs-keyword">var</span> shiftRestVertical = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(rest, note, dir)</span> </span>{
    <span class="hljs-keyword">var</span> delta = (note.isrest ? <span class="hljs-number">0.0</span> : <span class="hljs-number">1.0</span>) * dir;

    rest.line += delta;
    rest.max_line += delta;
    rest.min_line += delta;
    rest.note.setKeyLine(<span class="hljs-number">0</span>, rest.note.getKeyLine(<span class="hljs-number">0</span>) + (delta));
  };</pre></div>
        
      
        
        <p>Called from formatNotes :: center a rest between two notes</p>

        
          <div class='highlight'><pre>  <span class="hljs-keyword">var</span> centerRest = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(rest, noteU, noteL)</span> </span>{
    <span class="hljs-keyword">var</span> delta = rest.line - Vex.MidLine(noteU.min_line, noteL.max_line);
    rest.note.setKeyLine(<span class="hljs-number">0</span>, rest.note.getKeyLine(<span class="hljs-number">0</span>) - delta);
    rest.line -= delta;
    rest.max_line -= delta;
    rest.min_line -= delta;
  };</pre></div>
        
      
        
        <h2 id="static-methods">Static Methods</h2>
<p>Format notes inside a ModifierContext.</p>

        
          <div class='highlight'><pre>  StaveNote.format = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(notes, state)</span> </span>{
    <span class="hljs-keyword">if</span> (!notes || notes.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">if</span> (notes[<span class="hljs-number">0</span>].getStave() != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> StaveNote.formatByY(notes, state);

    <span class="hljs-keyword">var</span> notes_list= [];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; notes.length; i++) {
      <span class="hljs-keyword">var</span> props = notes[i].getKeyProps();
      <span class="hljs-keyword">var</span> line = props[<span class="hljs-number">0</span>].line;
      <span class="hljs-keyword">var</span> minL = props[props.length -<span class="hljs-number">1</span>].line;
      <span class="hljs-keyword">var</span> stem_dir = notes[i].getStemDirection();
      <span class="hljs-keyword">var</span> stem_max = notes[i].getStemLength() / <span class="hljs-number">10</span>;
      <span class="hljs-keyword">var</span> stem_min = notes[i].getStemMinumumLength() / <span class="hljs-number">10</span>;

      <span class="hljs-keyword">var</span> maxL;
      <span class="hljs-keyword">if</span> (notes[i].isRest()) {
        maxL = line + notes[i].glyph.line_above;
        minL = line - notes[i].glyph.line_below;
      } <span class="hljs-keyword">else</span> {
        maxL = stem_dir == <span class="hljs-number">1</span> ? props[props.length -<span class="hljs-number">1</span>].line + stem_max
             : props[props.length -<span class="hljs-number">1</span>].line;
        minL = stem_dir == <span class="hljs-number">1</span> ? props[<span class="hljs-number">0</span>].line
             : props[<span class="hljs-number">0</span>].line - stem_max;
      }
      notes_list.push(
        {line: props[<span class="hljs-number">0</span>].line,         <span class="hljs-comment">// note/rest base line</span>
         max_line: maxL,              <span class="hljs-comment">// note/rest upper bounds line</span>
         min_line: minL,              <span class="hljs-comment">// note/rest lower bounds line</span>
         isrest: notes[i].isRest(),
         stem_dir: stem_dir,
         stem_max: stem_max,          <span class="hljs-comment">// Maximum (default) note stem length;</span>
         stem_min: stem_min,          <span class="hljs-comment">// minimum note stem length</span>
         voice_shift: notes[i].getVoiceShiftWidth(),
         is_displaced: notes[i].isDisplaced(),   <span class="hljs-comment">// note manually displaced</span>
         note: notes[i]});
    }

    <span class="hljs-keyword">var</span> voices = notes_list.length;

    <span class="hljs-keyword">var</span> noteU = notes_list[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">var</span> noteM = voices &gt; <span class="hljs-number">2</span> ? notes_list[<span class="hljs-number">1</span>] : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> noteL = voices &gt; <span class="hljs-number">2</span> ? notes_list[<span class="hljs-number">2</span>] : notes_list[<span class="hljs-number">1</span>];</pre></div>
        
      
        
        <p>for two voice backward compatibility, ensure upper voice is stems up
for three voices, the voices must be in order (upper, middle, lower)</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">if</span> (voices == <span class="hljs-number">2</span> &amp;&amp; noteU.stem_dir == -<span class="hljs-number">1</span> &amp;&amp; noteL.stem_dir == <span class="hljs-number">1</span>) {
      noteU = notes_list[<span class="hljs-number">1</span>];
      noteL = notes_list[<span class="hljs-number">0</span>];
    }

    <span class="hljs-keyword">var</span> voice_x_shift = <span class="hljs-built_in">Math</span>.max(noteU.voice_shift, noteL.voice_shift);
    <span class="hljs-keyword">var</span> x_shift = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> stem_delta;</pre></div>
        
      
        
        <p>Test for two voice note intersection</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">if</span> (voices == <span class="hljs-number">2</span>) {
      <span class="hljs-keyword">var</span> line_spacing = noteU.stem_dir == noteL.stem_dir ? <span class="hljs-number">0.0</span> : <span class="hljs-number">0.5</span>;</pre></div>
        
      
        
        <p>if top voice is a middle voice, check stem intersection with lower voice</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">if</span> (noteU.stem_dir == noteL.stem_dir &amp;&amp;
          noteU.min_line &lt;= noteL.max_line) {
        <span class="hljs-keyword">if</span> (!noteU.isrest) {
          stem_delta = <span class="hljs-built_in">Math</span>.abs(noteU.line - (noteL.max_line + <span class="hljs-number">0.5</span>));
          stem_delta = <span class="hljs-built_in">Math</span>.max(stem_delta, noteU.stem_min);
          noteU.min_line = noteU.line - stem_delta;
          noteU.note.setStemLength(stem_delta * <span class="hljs-number">10</span>);
        }
      }
      <span class="hljs-keyword">if</span> (noteU.min_line &lt;= noteL.max_line + line_spacing) {
        <span class="hljs-keyword">if</span> (noteU.isrest) {</pre></div>
        
      
        
        <p>shift rest up</p>

        
          <div class='highlight'><pre>          shiftRestVertical(noteU, noteL, <span class="hljs-number">1</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (noteL.isrest) {</pre></div>
        
      
        
        <p>shift rest down</p>

        
          <div class='highlight'><pre>          shiftRestVertical(noteL, noteU, -<span class="hljs-number">1</span>);
        } <span class="hljs-keyword">else</span> {
          x_shift = voice_x_shift;
          <span class="hljs-keyword">if</span> (noteU.stem_dir == noteL.stem_dir)</pre></div>
        
      
        
        <p>upper voice is middle voice, so shift it right</p>

        
          <div class='highlight'><pre>            noteU.note.setXShift(x_shift + <span class="hljs-number">3</span>);
          <span class="hljs-keyword">else</span></pre></div>
        
      
        
        <p>shift lower voice right</p>

        
          <div class='highlight'><pre>            noteL.note.setXShift(x_shift);
        }
      }</pre></div>
        
      
        
        <p>format complete</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }</pre></div>
        
      
        
        <p>Check middle voice stem intersection with lower voice</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">if</span> (noteM != <span class="hljs-literal">null</span> &amp;&amp; noteM.min_line &lt; noteL.max_line + <span class="hljs-number">0.5</span>) {
      <span class="hljs-keyword">if</span> (!noteM.isrest) {
        stem_delta = <span class="hljs-built_in">Math</span>.abs(noteM.line - (noteL.max_line + <span class="hljs-number">0.5</span>));
        stem_delta = <span class="hljs-built_in">Math</span>.max(stem_delta, noteM.stem_min);
        noteM.min_line = noteM.line - stem_delta;
        noteM.note.setStemLength(stem_delta * <span class="hljs-number">10</span>);
      }
    }</pre></div>
        
      
        
        <p>For three voices, test if rests can be repositioned</p>
<p>Special case 1 :: middle voice rest between two notes</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">if</span> (noteM.isrest &amp;&amp; !noteU.isrest &amp;&amp; !noteL.isrest) {
      <span class="hljs-keyword">if</span> (noteU.min_line &lt;= noteM.max_line ||
          noteM.min_line &lt;= noteL.max_line) {
         <span class="hljs-keyword">var</span> rest_height = noteM.max_line - noteM.min_line;
         <span class="hljs-keyword">var</span> space = noteU.min_line - noteL.max_line;
         <span class="hljs-keyword">if</span> (rest_height &lt; space)</pre></div>
        
      
        
        <p>center middle voice rest between the upper and lower voices</p>

        
          <div class='highlight'><pre>           centerRest(noteM, noteU, noteL);
         <span class="hljs-keyword">else</span> {
           x_shift = voice_x_shift + <span class="hljs-number">3</span>;    <span class="hljs-comment">// shift middle rest right</span>
           noteM.note.setXShift(x_shift);
         }</pre></div>
        
      
        
        <p>format complete</p>

        
          <div class='highlight'><pre>         <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
    }</pre></div>
        
      
        
        <p>Special case 2 :: all voices are rests</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">if</span> (noteU.isrest &amp;&amp; noteM.isrest &amp;&amp; noteL.isrest) {</pre></div>
        
      
        
        <p>Shift upper voice rest up</p>

        
          <div class='highlight'><pre>      shiftRestVertical(noteU, noteM, <span class="hljs-number">1</span>);</pre></div>
        
      
        
        <p>Shift lower voice rest down</p>

        
          <div class='highlight'><pre>      shiftRestVertical(noteL, noteM, -<span class="hljs-number">1</span>);</pre></div>
        
      
        
        <p>format complete</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }</pre></div>
        
      
        
        <p>Test if any other rests can be repositioned</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">if</span> (noteM.isrest &amp;&amp; noteU.isrest &amp;&amp; noteM.min_line &lt;= noteL.max_line)</pre></div>
        
      
        
        <p>Shift middle voice rest up</p>

        
          <div class='highlight'><pre>      shiftRestVertical(noteM, noteL, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">if</span> (noteM.isrest &amp;&amp; noteL.isrest &amp;&amp; noteU.min_line &lt;= noteM.max_line)</pre></div>
        
      
        
        <p>Shift middle voice rest down</p>

        
          <div class='highlight'><pre>      shiftRestVertical(noteM, noteU, -<span class="hljs-number">1</span>);
    <span class="hljs-keyword">if</span> (noteU.isrest &amp;&amp; noteU.min_line &lt;= noteM.max_line)</pre></div>
        
      
        
        <p>shift upper voice rest up;</p>

        
          <div class='highlight'><pre>      shiftRestVertical(noteU, noteM, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">if</span> (noteL.isrest &amp;&amp; noteM.min_line &lt;= noteL.max_line)</pre></div>
        
      
        
        <p>shift lower voice rest down</p>

        
          <div class='highlight'><pre>      shiftRestVertical(noteL, noteM, -<span class="hljs-number">1</span>);</pre></div>
        
      
        
        <p>If middle voice intersects upper or lower voice</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">if</span> ((!noteU.isrest &amp;&amp; !noteM.isrest &amp;&amp; noteU.min_line &lt;= noteM.max_line + <span class="hljs-number">0.5</span>) ||
        (!noteM.isrest &amp;&amp; !noteL.isrest &amp;&amp; noteM.min_line &lt;= noteL.max_line)) {
      x_shift = voice_x_shift + <span class="hljs-number">3</span>;      <span class="hljs-comment">// shift middle note right</span>
      noteM.note.setXShift(x_shift);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  };

  StaveNote.formatByY = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(notes, state)</span> </span>{</pre></div>
        
      
        
        <p>NOTE: this function does not support more than two voices per stave
      use with care.</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">var</span> hasStave = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">var</span> i;

    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; notes.length; i++) {
      hasStave = hasStave &amp;&amp; notes[i].getStave() != <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">if</span> (!hasStave) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RERR(<span class="hljs-string">"Stave Missing"</span>,
      <span class="hljs-string">"All notes must have a stave - Vex.Flow.ModifierContext.formatMultiVoice!"</span>);

    <span class="hljs-keyword">var</span> x_shift = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; notes.length - <span class="hljs-number">1</span>; i++) {
      <span class="hljs-keyword">var</span> top_note = notes[i];
      <span class="hljs-keyword">var</span> bottom_note = notes[i + <span class="hljs-number">1</span>];

      <span class="hljs-keyword">if</span> (top_note.getStemDirection() == Vex.Flow.StaveNote.STEM_DOWN) {
        top_note = notes[i + <span class="hljs-number">1</span>];
        bottom_note = notes[i];
      }

      <span class="hljs-keyword">var</span> top_keys = top_note.getKeyProps();
      <span class="hljs-keyword">var</span> bottom_keys = bottom_note.getKeyProps();

      <span class="hljs-keyword">var</span> topY = top_note.getStave().getYForLine(top_keys[<span class="hljs-number">0</span>].line);
      <span class="hljs-keyword">var</span> bottomY = bottom_note.getStave().getYForLine(bottom_keys[bottom_keys.length - <span class="hljs-number">1</span>].line);

      <span class="hljs-keyword">var</span> line_space = top_note.getStave().options.spacing_between_lines_px;
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(topY - bottomY) == line_space / <span class="hljs-number">2</span>) {
        x_shift = top_note.getVoiceShiftWidth();
        bottom_note.setXShift(x_shift);
      }
    }

    state.right_shift += x_shift;
  };

  StaveNote.postFormat = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(notes)</span> </span>{
    <span class="hljs-keyword">if</span> (!notes) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    notes.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(note)</span> </span>{
      note.postFormat();
    });

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  };</pre></div>
        
      
        
        <h2 id="prototype-methods">Prototype Methods</h2>

        
          <div class='highlight'><pre>  Vex.Inherit(StaveNote, Vex.Flow.StemmableNote, {
    init: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(note_struct)</span> </span>{
      StaveNote.superclass.init.call(<span class="hljs-keyword">this</span>, note_struct);

      <span class="hljs-keyword">this</span>.keys = note_struct.keys;
      <span class="hljs-keyword">this</span>.clef = note_struct.clef;
      <span class="hljs-keyword">this</span>.octave_shift = note_struct.octave_shift;
      <span class="hljs-keyword">this</span>.beam = <span class="hljs-literal">null</span>;</pre></div>
        
      
        
        <p>Pull note rendering properties</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">this</span>.glyph = Vex.Flow.durationToGlyph(<span class="hljs-keyword">this</span>.duration, <span class="hljs-keyword">this</span>.noteType);
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.glyph) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RuntimeError(<span class="hljs-string">"BadArguments"</span>,
            <span class="hljs-string">"Invalid note initialization data (No glyph found): "</span> +
            <span class="hljs-built_in">JSON</span>.stringify(note_struct));
      }</pre></div>
        
      
        
        <p>if true, displace note to right</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">this</span>.displaced = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">this</span>.dot_shiftY = <span class="hljs-number">0</span>;</pre></div>
        
      
        
        <p>per-pitch properties</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">this</span>.keyProps = [];</pre></div>
        
      
        
        <p>for displaced ledger lines</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">this</span>.use_default_head_x = <span class="hljs-literal">false</span>;</pre></div>
        
      
        
        <p>Drawing</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">this</span>.note_heads = [];
      <span class="hljs-keyword">this</span>.modifiers = [];

      Vex.Merge(<span class="hljs-keyword">this</span>.render_options, {</pre></div>
        
      
        
        <p>font size for note heads and rests</p>

        
          <div class='highlight'><pre>        glyph_font_scale: <span class="hljs-number">35</span>,</pre></div>
        
      
        
        <p>number of stroke px to the left and right of head</p>

        
          <div class='highlight'><pre>        stroke_px: <span class="hljs-number">3</span>
      });

      <span class="hljs-keyword">this</span>.calculateKeyProps();

      <span class="hljs-keyword">this</span>.buildStem();</pre></div>
        
      
        
        <p>Set the stem direction</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">if</span> (note_struct.auto_stem) {
        <span class="hljs-keyword">this</span>.autoStem();
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.setStemDirection(note_struct.stem_direction);
      }

      <span class="hljs-keyword">this</span>.buildNoteHeads();</pre></div>
        
      
        
        <p>Calculate left/right padding</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">this</span>.calcExtraPx();
    },</pre></div>
        
      
        
        <p>Builds a <code>Stem</code> for the note</p>

        
          <div class='highlight'><pre>    buildStem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> glyph = <span class="hljs-keyword">this</span>.getGlyph();

      <span class="hljs-keyword">var</span> y_extend = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> (glyph.code_head == <span class="hljs-string">"v95"</span> || glyph.code_head == <span class="hljs-string">"v3e"</span>) {
         y_extend = -<span class="hljs-number">4</span>;
      }

      <span class="hljs-keyword">var</span> stem = <span class="hljs-keyword">new</span> Stem({
        y_extend: y_extend
      });

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isRest()) {
        stem.hide = <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">this</span>.setStem(stem);
    },</pre></div>
        
      
        
        <p>Builds a <code>NoteHead</code> for each key in the note</p>

        
          <div class='highlight'><pre>    buildNoteHeads: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> stem_direction = <span class="hljs-keyword">this</span>.getStemDirection();

      <span class="hljs-keyword">var</span> keys = <span class="hljs-keyword">this</span>.getKeys();

      <span class="hljs-keyword">var</span> last_line = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> line_diff = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> displaced = <span class="hljs-literal">false</span>;</pre></div>
        
      
        
        <p>Draw notes from bottom to top.</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">var</span> start_i = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> end_i = keys.length;
      <span class="hljs-keyword">var</span> step_i = <span class="hljs-number">1</span>;</pre></div>
        
      
        
        <p>For down-stem notes, we draw from top to bottom.</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">if</span> (stem_direction === Stem.DOWN) {
        start_i = keys.length - <span class="hljs-number">1</span>;
        end_i = -<span class="hljs-number">1</span>;
        step_i = -<span class="hljs-number">1</span>;
      }

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = start_i; i != end_i; i += step_i) {
        <span class="hljs-keyword">var</span> note_props = <span class="hljs-keyword">this</span>.keyProps[i];

        <span class="hljs-keyword">var</span> line = note_props.line;</pre></div>
        
      
        
        <p>Keep track of last line with a note head, so that consecutive heads
are correctly displaced.</p>

        
          <div class='highlight'><pre>        <span class="hljs-keyword">if</span> (last_line === <span class="hljs-literal">null</span>) {
          last_line = line;
        } <span class="hljs-keyword">else</span> {
          line_diff = <span class="hljs-built_in">Math</span>.abs(last_line - line);
          <span class="hljs-keyword">if</span> (line_diff === <span class="hljs-number">0</span> || line_diff === <span class="hljs-number">0.5</span>) {
            displaced = !displaced;
          } <span class="hljs-keyword">else</span> {
            displaced = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">this</span>.use_default_head_x = <span class="hljs-literal">true</span>;
          }
        }
        last_line = line;

        <span class="hljs-keyword">var</span> note_head = <span class="hljs-keyword">new</span> NoteHead({
          duration: <span class="hljs-keyword">this</span>.duration,
          note_type: <span class="hljs-keyword">this</span>.noteType,
          displaced: displaced,
          stem_direction: stem_direction,
          custom_glyph_code: note_props.code,
          glyph_font_scale: <span class="hljs-keyword">this</span>.render_options.glyph_font_scale,
          x_shift: note_props.shift_right,
          line: note_props.line
        });

        <span class="hljs-keyword">this</span>.note_heads[i] = note_head;
      }
    },</pre></div>
        
      
        
        <p>Automatically sets the stem direction based on the keys in the note</p>

        
          <div class='highlight'><pre>    autoStem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> auto_stem_direction;</pre></div>
        
      
        
        <p>Figure out optimal stem direction based on given notes</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">this</span>.min_line = <span class="hljs-keyword">this</span>.keyProps[<span class="hljs-number">0</span>].line;
      <span class="hljs-keyword">this</span>.max_line = <span class="hljs-keyword">this</span>.keyProps[<span class="hljs-keyword">this</span>.keyProps.length - <span class="hljs-number">1</span>].line;
      <span class="hljs-keyword">var</span> decider = (<span class="hljs-keyword">this</span>.min_line + <span class="hljs-keyword">this</span>.max_line) / <span class="hljs-number">2</span>;

      <span class="hljs-keyword">if</span> (decider &lt; <span class="hljs-number">3</span>) {
        auto_stem_direction = <span class="hljs-number">1</span>;
      } <span class="hljs-keyword">else</span> {
        auto_stem_direction = -<span class="hljs-number">1</span>;
      }

      <span class="hljs-keyword">this</span>.setStemDirection(auto_stem_direction);
    },</pre></div>
        
      
        
        <p>Calculates and stores the properties for each key in the note</p>

        
          <div class='highlight'><pre>    calculateKeyProps: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> last_line = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.keys.length; ++i) {
        <span class="hljs-keyword">var</span> key = <span class="hljs-keyword">this</span>.keys[i];</pre></div>
        
      
        
        <p>All rests use the same position on the line.
if (this.glyph.rest) key = this.glyph.position;</p>

        
          <div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.glyph.rest) <span class="hljs-keyword">this</span>.glyph.position = key;
        <span class="hljs-keyword">var</span> options = { octave_shift: <span class="hljs-keyword">this</span>.octave_shift || <span class="hljs-number">0</span> };
        <span class="hljs-keyword">var</span> props = Vex.Flow.keyProperties(key, <span class="hljs-keyword">this</span>.clef, options);
        <span class="hljs-keyword">if</span> (!props) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RuntimeError(<span class="hljs-string">"BadArguments"</span>,
              <span class="hljs-string">"Invalid key for note properties: "</span> + key);
        }</pre></div>
        
      
        
        <p>Override line placement for default rests</p>

        
          <div class='highlight'><pre>        <span class="hljs-keyword">if</span> (props.key === <span class="hljs-string">"R"</span>) {
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.duration === <span class="hljs-string">"1"</span> || <span class="hljs-keyword">this</span>.duration === <span class="hljs-string">"w"</span>) {
            props.line = <span class="hljs-number">4</span>;
          } <span class="hljs-keyword">else</span> {
            props.line = <span class="hljs-number">3</span>;
          }
        }</pre></div>
        
      
        
        <p>Calculate displacement of this note</p>

        
          <div class='highlight'><pre>        <span class="hljs-keyword">var</span> line = props.line;
        <span class="hljs-keyword">if</span> (last_line === <span class="hljs-literal">null</span>) {
          last_line = line;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(last_line - line) == <span class="hljs-number">0.5</span>) {
            <span class="hljs-keyword">this</span>.displaced = <span class="hljs-literal">true</span>;
            props.displaced = <span class="hljs-literal">true</span>;</pre></div>
        
      
        
        <p>Have to mark the previous note as
displaced as well, for modifier placement</p>

        
          <div class='highlight'><pre>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.keyProps.length &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">this</span>.keyProps[i-<span class="hljs-number">1</span>].displaced = <span class="hljs-literal">true</span>;
            }
          }
        }

        last_line = line;
        <span class="hljs-keyword">this</span>.keyProps.push(props);
      }</pre></div>
        
      
        
        <p>Sort the notes from lowest line to highest line</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">this</span>.keyProps.sort(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{ <span class="hljs-keyword">return</span> a.line - b.line; });
    },</pre></div>
        
      
        
        <p>Get the <code>BoundingBox</code> for the entire note</p>

        
          <div class='highlight'><pre>    getBoundingBox: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.preFormatted) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RERR(<span class="hljs-string">"UnformattedNote"</span>,
          <span class="hljs-string">"Can't call getBoundingBox on an unformatted note."</span>);

      <span class="hljs-keyword">var</span> metrics = <span class="hljs-keyword">this</span>.getMetrics();

      <span class="hljs-keyword">var</span> w = metrics.width;
      <span class="hljs-keyword">var</span> x = <span class="hljs-keyword">this</span>.getAbsoluteX() - metrics.modLeftPx - metrics.extraLeftPx;

      <span class="hljs-keyword">var</span> min_y = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> max_y = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> half_line_spacing = <span class="hljs-keyword">this</span>.getStave().getSpacingBetweenLines() / <span class="hljs-number">2</span>;
      <span class="hljs-keyword">var</span> line_spacing = half_line_spacing * <span class="hljs-number">2</span>;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isRest()) {
        <span class="hljs-keyword">var</span> y = <span class="hljs-keyword">this</span>.ys[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">var</span> frac = Vex.Flow.durationToFraction(<span class="hljs-keyword">this</span>.duration);
        <span class="hljs-keyword">if</span> (frac.equals(<span class="hljs-number">1</span>) || frac.equals(<span class="hljs-number">2</span>)) {
          min_y = y - half_line_spacing;
          max_y = y + half_line_spacing;
        } <span class="hljs-keyword">else</span> {
          min_y = y - (<span class="hljs-keyword">this</span>.glyph.line_above * line_spacing);
          max_y = y + (<span class="hljs-keyword">this</span>.glyph.line_below * line_spacing);
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.glyph.stem) {
        <span class="hljs-keyword">var</span> ys = <span class="hljs-keyword">this</span>.getStemExtents();
        ys.baseY += half_line_spacing * <span class="hljs-keyword">this</span>.stem_direction;
        min_y = Vex.Min(ys.topY, ys.baseY);
        max_y = Vex.Max(ys.topY, ys.baseY);
      } <span class="hljs-keyword">else</span> {
        min_y = <span class="hljs-literal">null</span>;
        max_y = <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.ys.length; ++i) {
          <span class="hljs-keyword">var</span> yy = <span class="hljs-keyword">this</span>.ys[i];
          <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span>) {
            min_y = yy;
            max_y = yy;
          } <span class="hljs-keyword">else</span> {
            min_y = Vex.Min(yy, min_y);
            max_y = Vex.Max(yy, max_y);
          }
          min_y -= half_line_spacing;
          max_y += half_line_spacing;
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vex.Flow.BoundingBox(x, min_y, w, max_y - min_y);
    },</pre></div>
        
      
        
        <p>Gets the line number of the top or bottom note in the chord.
If <code>is_top_note</code> is <code>true</code> then get the top note</p>

        
          <div class='highlight'><pre>    getLineNumber: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(is_top_note)</span> </span>{
      <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.keyProps.length) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RERR(<span class="hljs-string">"NoKeyProps"</span>,
          <span class="hljs-string">"Can't get bottom note line, because note is not initialized properly."</span>);
      <span class="hljs-keyword">var</span> result_line = <span class="hljs-keyword">this</span>.keyProps[<span class="hljs-number">0</span>].line;</pre></div>
        
      
        
        <p>No precondition assumed for sortedness of keyProps array</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-keyword">this</span>.keyProps.length; i++){
        <span class="hljs-keyword">var</span> this_line = <span class="hljs-keyword">this</span>.keyProps[i].line;
        <span class="hljs-keyword">if</span>(is_top_note)
          <span class="hljs-keyword">if</span>(this_line &gt; result_line)
                result_line = this_line;
        <span class="hljs-keyword">else</span>
          <span class="hljs-keyword">if</span>(this_line &lt; result_line)
            result_line = this_line;
      }

      <span class="hljs-keyword">return</span> result_line;
    },</pre></div>
        
      
        
        <p>Determine if current note is a rest</p>

        
          <div class='highlight'><pre>    isRest: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.glyph.rest; },</pre></div>
        
      
        
        <p>Determine if the current note is a chord</p>

        
          <div class='highlight'><pre>    isChord: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.isRest() &amp;&amp; <span class="hljs-keyword">this</span>.keys.length &gt; <span class="hljs-number">1</span>; },</pre></div>
        
      
        
        <p>Determine if the <code>StaveNote</code> has a stem</p>

        
          <div class='highlight'><pre>    hasStem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.glyph.stem; },</pre></div>
        
      
        
        <p>Get the <code>y</code> coordinate for text placed on the top/bottom of a
note at a desired <code>text_line</code></p>

        
          <div class='highlight'><pre>    getYForTopText: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(text_line)</span> </span>{
      <span class="hljs-keyword">var</span> extents = <span class="hljs-keyword">this</span>.getStemExtents();
      <span class="hljs-keyword">return</span> Vex.Min(<span class="hljs-keyword">this</span>.stave.getYForTopText(text_line),
          extents.topY - (<span class="hljs-keyword">this</span>.render_options.annotation_spacing * (text_line + <span class="hljs-number">1</span>)));
    },
    getYForBottomText: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(text_line)</span> </span>{
      <span class="hljs-keyword">var</span> extents = <span class="hljs-keyword">this</span>.getStemExtents();
      <span class="hljs-keyword">return</span> Vex.Max(<span class="hljs-keyword">this</span>.stave.getYForTopText(text_line),
          extents.baseY + (<span class="hljs-keyword">this</span>.render_options.annotation_spacing * (text_line)));
    },</pre></div>
        
      
        
        <p>Sets the current note to the provided <code>stave</code>. This applies
<code>y</code> values to the <code>NoteHeads</code>.</p>

        
          <div class='highlight'><pre>    setStave: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(stave)</span> </span>{
      <span class="hljs-keyword">var</span> superclass = Vex.Flow.StaveNote.superclass;
      superclass.setStave.call(<span class="hljs-keyword">this</span>, stave);

      <span class="hljs-keyword">var</span> ys = <span class="hljs-keyword">this</span>.note_heads.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(note_head)</span> </span>{
        note_head.setStave(stave);
        <span class="hljs-keyword">return</span> note_head.getY();
      });

      <span class="hljs-keyword">this</span>.setYs(ys);

      <span class="hljs-keyword">var</span> bounds = <span class="hljs-keyword">this</span>.getNoteHeadBounds();
      <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.beam){
	<span class="hljs-keyword">this</span>.stem.setYBounds(bounds.y_top, bounds.y_bottom);
      }

      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    },</pre></div>
        
      
        
        <p>Get the pitches in the note</p>

        
          <div class='highlight'><pre>    getKeys: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.keys; },</pre></div>
        
      
        
        <p>Get the properties for all the keys in the note</p>

        
          <div class='highlight'><pre>    getKeyProps: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.keyProps;
    },</pre></div>
        
      
        
        <p>Check if note is shifted to the right</p>

        
          <div class='highlight'><pre>    isDisplaced: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.displaced;
    },</pre></div>
        
      
        
        <p>Sets whether shift note to the right. <code>displaced</code> is a <code>boolean</code></p>

        
          <div class='highlight'><pre>    setNoteDisplaced: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(displaced)</span> </span>{
      <span class="hljs-keyword">this</span>.displaced = displaced;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    },</pre></div>
        
      
        
        <p>Get the starting <code>x</code> coordinate for a <code>StaveTie</code></p>

        
          <div class='highlight'><pre>    getTieRightX: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> tieStartX = <span class="hljs-keyword">this</span>.getAbsoluteX();
      tieStartX += <span class="hljs-keyword">this</span>.glyph.head_width + <span class="hljs-keyword">this</span>.x_shift + <span class="hljs-keyword">this</span>.extraRightPx;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.modifierContext) tieStartX += <span class="hljs-keyword">this</span>.modifierContext.getExtraRightPx();
      <span class="hljs-keyword">return</span> tieStartX;
    },</pre></div>
        
      
        
        <p>Get the ending <code>x</code> coordinate for a <code>StaveTie</code></p>

        
          <div class='highlight'><pre>    getTieLeftX: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> tieEndX = <span class="hljs-keyword">this</span>.getAbsoluteX();
      tieEndX += <span class="hljs-keyword">this</span>.x_shift - <span class="hljs-keyword">this</span>.extraLeftPx;
      <span class="hljs-keyword">return</span> tieEndX;
    },</pre></div>
        
      
        
        <p>Get the stave line on which to place a rest</p>

        
          <div class='highlight'><pre>    getLineForRest: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> rest_line = <span class="hljs-keyword">this</span>.keyProps[<span class="hljs-number">0</span>].line;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.keyProps.length &gt; <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">var</span> last_line  = <span class="hljs-keyword">this</span>.keyProps[<span class="hljs-keyword">this</span>.keyProps.length - <span class="hljs-number">1</span>].line;
        <span class="hljs-keyword">var</span> top = Vex.Max(rest_line, last_line);
        <span class="hljs-keyword">var</span> bot = Vex.Min(rest_line, last_line);
        rest_line = Vex.MidLine(top, bot);
      }

      <span class="hljs-keyword">return</span> rest_line;
    },</pre></div>
        
      
        
        <p>Get the default <code>x</code> and <code>y</code> coordinates for the provided <code>position</code>
and key <code>index</code></p>

        
          <div class='highlight'><pre>    getModifierStartXY: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(position, index)</span> </span>{
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.preFormatted) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RERR(<span class="hljs-string">"UnformattedNote"</span>,
          <span class="hljs-string">"Can't call GetModifierStartXY on an unformatted note"</span>);

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.ys.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RERR(<span class="hljs-string">"NoYValues"</span>,
          <span class="hljs-string">"No Y-Values calculated for this note."</span>);

      <span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> (position == Vex.Flow.Modifier.Position.LEFT) {</pre></div>
        
      
        
        <p>extra_left_px</p>

        
          <div class='highlight'><pre>        x = -<span class="hljs-number">1</span> * <span class="hljs-number">2</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (position == Vex.Flow.Modifier.Position.RIGHT) {</pre></div>
        
      
        
        <p>extra_right_px</p>

        
          <div class='highlight'><pre>        x = <span class="hljs-keyword">this</span>.glyph.head_width + <span class="hljs-keyword">this</span>.x_shift + <span class="hljs-number">2</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (position == Vex.Flow.Modifier.Position.BELOW ||
                 position == Vex.Flow.Modifier.Position.ABOVE) {
        x = <span class="hljs-keyword">this</span>.glyph.head_width / <span class="hljs-number">2</span>;
      }

      <span class="hljs-keyword">return</span> { x: <span class="hljs-keyword">this</span>.getAbsoluteX() + x, y: <span class="hljs-keyword">this</span>.ys[index] };
    },</pre></div>
        
      
        
        <p>Sets the notehead at <code>index</code> to the provided coloring <code>style</code>.</p>
<p><code>style</code> is an <code>object</code> with the following properties: <code>shadowColor</code>,
<code>shadowBlur</code>, <code>fillStyle</code>, <code>strokeStyle</code></p>

        
          <div class='highlight'><pre>    setKeyStyle: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(index, style)</span> </span>{
      <span class="hljs-keyword">this</span>.note_heads[index].setStyle(style);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    },

    setKeyLine: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(index, line)</span> </span>{
      <span class="hljs-keyword">this</span>.keyProps[index].line = line;
      <span class="hljs-keyword">this</span>.note_heads[index].setLine(line);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    },

    getKeyLine: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(index)</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.keyProps[index].line;
    },</pre></div>
        
      
        
        <p>Add self to modifier context. <code>mContext</code> is the <code>ModifierContext</code>
to be added to.</p>

        
          <div class='highlight'><pre>    addToModifierContext: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(mContext)</span> </span>{
      <span class="hljs-keyword">this</span>.setModifierContext(mContext);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.modifiers.length; ++i) {
        <span class="hljs-keyword">this</span>.modifierContext.addModifier(<span class="hljs-keyword">this</span>.modifiers[i]);
      }
      <span class="hljs-keyword">this</span>.modifierContext.addModifier(<span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">this</span>.setPreFormatted(<span class="hljs-literal">false</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    },</pre></div>
        
      
        
        <p>Generic function to add modifiers to a note</p>
<p>Parameters:</p>
<ul>
<li><code>index</code>: The index of the key that we’re modifying</li>
<li><code>modifier</code>: The modifier to add</li>
</ul>

        
          <div class='highlight'><pre>    addModifier: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(index, modifier)</span> </span>{
      modifier.setNote(<span class="hljs-keyword">this</span>);
      modifier.setIndex(index);
      <span class="hljs-keyword">this</span>.modifiers.push(modifier);
      <span class="hljs-keyword">this</span>.setPreFormatted(<span class="hljs-literal">false</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    },</pre></div>
        
      
        
        <p>Helper function to add an accidental to a key</p>

        
          <div class='highlight'><pre>    addAccidental: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(index, accidental)</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.addModifier(index, accidental);
    },</pre></div>
        
      
        
        <p>Helper function to add an articulation to a key</p>

        
          <div class='highlight'><pre>    addArticulation: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(index, articulation)</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.addModifier(index, articulation);
    },</pre></div>
        
      
        
        <p>Helper function to add an annotation to a key</p>

        
          <div class='highlight'><pre>    addAnnotation: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(index, annotation)</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.addModifier(index, annotation);
    },</pre></div>
        
      
        
        <p>Helper function to add a dot on a specific key</p>

        
          <div class='highlight'><pre>    addDot: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(index)</span> </span>{
      <span class="hljs-keyword">var</span> dot = <span class="hljs-keyword">new</span> Vex.Flow.Dot();
      dot.setDotShiftY(<span class="hljs-keyword">this</span>.glyph.dot_shiftY);
      <span class="hljs-keyword">this</span>.dots++;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.addModifier(index, dot);
    },</pre></div>
        
      
        
        <p>Convenience method to add dot to all keys in note</p>

        
          <div class='highlight'><pre>    addDotToAll: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.keys.length; ++i)
        <span class="hljs-keyword">this</span>.addDot(i);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    },</pre></div>
        
      
        
        <p>Get all accidentals in the <code>ModifierContext</code></p>

        
          <div class='highlight'><pre>    getAccidentals: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.modifierContext.getModifiers(<span class="hljs-string">"accidentals"</span>);
    },</pre></div>
        
      
        
        <p>Get all dots in the <code>ModifierContext</code></p>

        
          <div class='highlight'><pre>    getDots: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.modifierContext.getModifiers(<span class="hljs-string">"dots"</span>);
    },</pre></div>
        
      
        
        <p>Get the width of the note if it is displaced. Used for <code>Voice</code>
formatting</p>

        
          <div class='highlight'><pre>    getVoiceShiftWidth: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</pre></div>
        
      
        
        <p>TODO: may need to accomodate for dot here.</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.glyph.head_width * (<span class="hljs-keyword">this</span>.displaced ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>);
    },</pre></div>
        
      
        
        <p>Calculates and sets the extra pixels to the left or right
if the note is displaced</p>

        
          <div class='highlight'><pre>    calcExtraPx: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">this</span>.setExtraLeftPx((<span class="hljs-keyword">this</span>.displaced &amp;&amp; <span class="hljs-keyword">this</span>.stem_direction == -<span class="hljs-number">1</span>) ?
          <span class="hljs-keyword">this</span>.glyph.head_width : <span class="hljs-number">0</span>);
      <span class="hljs-keyword">this</span>.setExtraRightPx((<span class="hljs-keyword">this</span>.displaced &amp;&amp; <span class="hljs-keyword">this</span>.stem_direction == <span class="hljs-number">1</span>) ?
          <span class="hljs-keyword">this</span>.glyph.head_width : <span class="hljs-number">0</span>);
    },</pre></div>
        
      
        
        <p>Pre-render formatting</p>

        
          <div class='highlight'><pre>    preFormat: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.preFormatted) <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.modifierContext) <span class="hljs-keyword">this</span>.modifierContext.preFormat();

      <span class="hljs-keyword">var</span> width = <span class="hljs-keyword">this</span>.glyph.head_width + <span class="hljs-keyword">this</span>.extraLeftPx + <span class="hljs-keyword">this</span>.extraRightPx;</pre></div>
        
      
        
        <p>For upward flagged notes, the width of the flag needs to be added</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.glyph.flag &amp;&amp; <span class="hljs-keyword">this</span>.beam === <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.stem_direction == <span class="hljs-number">1</span>) {
        width += <span class="hljs-keyword">this</span>.glyph.head_width;
      }

      <span class="hljs-keyword">this</span>.setWidth(width);
      <span class="hljs-keyword">this</span>.setPreFormatted(<span class="hljs-literal">true</span>);
    },</pre></div>
        
      
        
        <p>Gets the staff line and y value for the highest and lowest noteheads</p>

        
          <div class='highlight'><pre>    getNoteHeadBounds: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</pre></div>
        
      
        
        <p>Top and bottom Y values for stem.</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">var</span> y_top = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> y_bottom = <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">var</span> highest_line = <span class="hljs-keyword">this</span>.stave.getNumLines();
      <span class="hljs-keyword">var</span> lowest_line = <span class="hljs-number">1</span>;

      <span class="hljs-keyword">this</span>.note_heads.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(note_head)</span> </span>{
        <span class="hljs-keyword">var</span> line = note_head.getLine();
        <span class="hljs-keyword">var</span> y = note_head.getY();

        <span class="hljs-keyword">if</span> (y_top === <span class="hljs-literal">null</span> || y &lt; y_top)  {
          y_top = y;
        }

        <span class="hljs-keyword">if</span> (y_bottom === <span class="hljs-literal">null</span> || y &gt; y_bottom) {
          y_bottom = y;
        }

        highest_line = line &gt; highest_line ? line : highest_line;
        lowest_line = line &lt; lowest_line ? line : lowest_line;

      }, <span class="hljs-keyword">this</span>);

      <span class="hljs-keyword">return</span> {
        y_top: y_top,
        y_bottom: y_bottom,
        highest_line: highest_line,
        lowest_line: lowest_line
      };
    },</pre></div>
        
      
        
        <p>Get the starting <code>x</code> coordinate for the noteheads</p>

        
          <div class='highlight'><pre>    getNoteHeadBeginX: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAbsoluteX() + <span class="hljs-keyword">this</span>.x_shift;
    },</pre></div>
        
      
        
        <p>Get the ending <code>x</code> coordinate for the noteheads</p>

        
          <div class='highlight'><pre>    getNoteHeadEndX: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
      <span class="hljs-keyword">var</span> x_begin = <span class="hljs-keyword">this</span>.getNoteHeadBeginX();
      <span class="hljs-keyword">return</span> x_begin + <span class="hljs-keyword">this</span>.glyph.head_width - (Vex.Flow.STEM_WIDTH / <span class="hljs-number">2</span>);
    },</pre></div>
        
      
        
        <p>Draw the ledger lines between the stave and the highest/lowest keys</p>

        
          <div class='highlight'><pre>    drawLedgerLines: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isRest()) { <span class="hljs-keyword">return</span>; }
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.context) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RERR(<span class="hljs-string">"NoCanvasContext"</span>,
          <span class="hljs-string">"Can't draw without a canvas context."</span>);
      <span class="hljs-keyword">var</span> ctx = <span class="hljs-keyword">this</span>.context;

      <span class="hljs-keyword">var</span> bounds = <span class="hljs-keyword">this</span>.getNoteHeadBounds();
      <span class="hljs-keyword">var</span> highest_line = bounds.highest_line;
      <span class="hljs-keyword">var</span> lowest_line = bounds.lowest_line;
      <span class="hljs-keyword">var</span> head_x = <span class="hljs-keyword">this</span>.note_heads[<span class="hljs-number">0</span>].getAbsoluteX();      
      
      <span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>;
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stroke</span><span class="hljs-params">(y)</span> </span>{
        <span class="hljs-keyword">if</span> (that.use_default_head_x === <span class="hljs-literal">true</span>)  {
          head_x = that.getAbsoluteX() + that.x_shift;
        }
        <span class="hljs-keyword">var</span> x = head_x - that.render_options.stroke_px;
        <span class="hljs-keyword">var</span> length = ((head_x + that.glyph.head_width) - head_x) +
          (that.render_options.stroke_px * <span class="hljs-number">2</span>);

        ctx.fillRect(x, y, length, <span class="hljs-number">1</span>);
      }

      <span class="hljs-keyword">var</span> line; <span class="hljs-comment">// iterator</span>
      <span class="hljs-keyword">for</span> (line = <span class="hljs-number">6</span>; line &lt;= highest_line; ++line) {
        stroke(<span class="hljs-keyword">this</span>.stave.getYForNote(line));
      }

      <span class="hljs-keyword">for</span> (line = <span class="hljs-number">0</span>; line &gt;= lowest_line; --line) {
        stroke(<span class="hljs-keyword">this</span>.stave.getYForNote(line));
      }
    },</pre></div>
        
      
        
        <p>Draw all key modifiers</p>

        
          <div class='highlight'><pre>    drawModifiers: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.context) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RERR(<span class="hljs-string">"NoCanvasContext"</span>,
          <span class="hljs-string">"Can't draw without a canvas context."</span>);
      <span class="hljs-keyword">var</span> ctx = <span class="hljs-keyword">this</span>.context;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.modifiers.length; i++) {
        <span class="hljs-keyword">var</span> mod = <span class="hljs-keyword">this</span>.modifiers[i];
        <span class="hljs-keyword">var</span> note_head = <span class="hljs-keyword">this</span>.note_heads[mod.getIndex()];
        <span class="hljs-keyword">var</span> key_style = note_head.getStyle();
        <span class="hljs-keyword">if</span>(key_style) {
            ctx.save();
            note_head.applyStyle(ctx);
        }
        mod.setContext(ctx);
        mod.draw();
        <span class="hljs-keyword">if</span>(key_style) {
            ctx.restore();
        }
      }
    },</pre></div>
        
      
        
        <p>Draw the flag for the note</p>

        
          <div class='highlight'><pre>    drawFlag: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.context) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RERR(<span class="hljs-string">"NoCanvasContext"</span>,
          <span class="hljs-string">"Can't draw without a canvas context."</span>);
      <span class="hljs-keyword">var</span> ctx = <span class="hljs-keyword">this</span>.context;
      <span class="hljs-keyword">var</span> glyph = <span class="hljs-keyword">this</span>.getGlyph();
      <span class="hljs-keyword">var</span> render_flag = <span class="hljs-keyword">this</span>.beam === <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> bounds = <span class="hljs-keyword">this</span>.getNoteHeadBounds();

      <span class="hljs-keyword">var</span> x_begin = <span class="hljs-keyword">this</span>.getNoteHeadBeginX();
      <span class="hljs-keyword">var</span> x_end = <span class="hljs-keyword">this</span>.getNoteHeadEndX();

      <span class="hljs-keyword">if</span> (glyph.flag &amp;&amp; render_flag) {
        <span class="hljs-keyword">var</span> note_stem_height = <span class="hljs-keyword">this</span>.stem.getHeight();
        <span class="hljs-keyword">var</span> flag_x, flag_y, flag_code;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.getStemDirection() === Stem.DOWN) {</pre></div>
        
      
        
        <p>Down stems have flags on the left.</p>

        
          <div class='highlight'><pre>          flag_x = x_begin + <span class="hljs-number">1</span>;
          flag_y = bounds.y_top - note_stem_height + <span class="hljs-number">2</span>;
          flag_code = glyph.code_flag_downstem;

        } <span class="hljs-keyword">else</span> {</pre></div>
        
      
        
        <p>Up stems have flags on the left.</p>

        
          <div class='highlight'><pre>          flag_x = x_end + <span class="hljs-number">1</span>;
          flag_y = bounds.y_bottom - note_stem_height - <span class="hljs-number">2</span>;
          flag_code = glyph.code_flag_upstem;
        }</pre></div>
        
      
        
        <p>Draw the Flag</p>

        
          <div class='highlight'><pre>        Vex.Flow.renderGlyph(ctx, flag_x, flag_y,
            <span class="hljs-keyword">this</span>.render_options.glyph_font_scale, flag_code);
      }
    },</pre></div>
        
      
        
        <p>Draw the NoteHeads</p>

        
          <div class='highlight'><pre>    drawNoteHeads: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
      <span class="hljs-keyword">this</span>.note_heads.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(note_head)</span> </span>{
        note_head.setContext(<span class="hljs-keyword">this</span>.context).draw();
      }, <span class="hljs-keyword">this</span>);
    },</pre></div>
        
      
        
        <p>Render the stem onto the canvas</p>

        
          <div class='highlight'><pre>    drawStem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(stem_struct)</span></span>{
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.context) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RERR(<span class="hljs-string">"NoCanvasContext"</span>,
          <span class="hljs-string">"Can't draw without a canvas context."</span>);

      <span class="hljs-keyword">if</span> (stem_struct) {
        <span class="hljs-keyword">this</span>.setStem(<span class="hljs-keyword">new</span> Stem(stem_struct));
      }

      <span class="hljs-keyword">this</span>.stem.setContext(<span class="hljs-keyword">this</span>.context).draw();
    },</pre></div>
        
      
        
        <p>Draws all the <code>StaveNote</code> parts. This is the main drawing method.</p>

        
          <div class='highlight'><pre>    draw: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.context) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RERR(<span class="hljs-string">"NoCanvasContext"</span>,
          <span class="hljs-string">"Can't draw without a canvas context."</span>);
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.stave) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RERR(<span class="hljs-string">"NoStave"</span>,
          <span class="hljs-string">"Can't draw without a stave."</span>);
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.ys.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RERR(<span class="hljs-string">"NoYValues"</span>,
          <span class="hljs-string">"Can't draw note without Y values."</span>);

      <span class="hljs-keyword">var</span> x_begin = <span class="hljs-keyword">this</span>.getNoteHeadBeginX();
      <span class="hljs-keyword">var</span> x_end = <span class="hljs-keyword">this</span>.getNoteHeadEndX();

      <span class="hljs-keyword">var</span> render_stem = <span class="hljs-keyword">this</span>.hasStem() &amp;&amp; !<span class="hljs-keyword">this</span>.beam;</pre></div>
        
      
        
        <p>Format note head x positions</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">this</span>.note_heads.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(note_head)</span> </span>{
        note_head.setX(x_begin);
      }, <span class="hljs-keyword">this</span>);</pre></div>
        
      
        
        <p>Format stem x positions</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">this</span>.stem.setNoteHeadXBounds(x_begin, x_end);

      L(<span class="hljs-string">"Rendering "</span>, <span class="hljs-keyword">this</span>.isChord() ? <span class="hljs-string">"chord :"</span> : <span class="hljs-string">"note :"</span>, <span class="hljs-keyword">this</span>.keys);</pre></div>
        
      
        
        <p>Draw each part of the note</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">this</span>.drawLedgerLines();
      <span class="hljs-keyword">if</span> (render_stem) <span class="hljs-keyword">this</span>.drawStem();
      <span class="hljs-keyword">this</span>.drawNoteHeads();
      <span class="hljs-keyword">this</span>.drawFlag();
      <span class="hljs-keyword">this</span>.drawModifiers();
    }
  });

  <span class="hljs-keyword">return</span> StaveNote;
}());</pre></div>
        
      
      <div class="fleur">h</div>
    </div>
  </div>
</body>
</html>
